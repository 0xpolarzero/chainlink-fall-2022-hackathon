{
  "language": "Solidity",
  "sources": {
    "contracts/IPromiseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IPromiseFactory {\n    function addTwitterVerifiedUser(\n        address _userAddress,\n        string memory _username\n    ) external;\n}\n"
    },
    "contracts/VerifyTwitterMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// Make sure it is compatible with all ^0.7.0, ^0.8.0 and ^0.8.16\npragma solidity ^0.8.0;\n\nimport \"./tests/ChainlinkClientTestHelper.sol\";\nimport \"./tests/ConfirmedOwnerTestHelper.sol\";\nimport \"./IPromiseFactory.sol\";\n\n/**\n * @notice This contract is used to test the VerifyTwitter contract\n * Everything is exactly the same, except that it inherits from:\n * - ChainlinkClientTestHelper\n * - ConfirmedOwnerTestHelper\n * ... instead of the original contracts.\n * This allows us to mock the ChainlinkClient and ConfirmedOwner contracts\n */\n\ncontract VerifyTwitterMock is\n    ChainlinkClientTestHelper,\n    ConfirmedOwnerTestHelper\n{\n    using Chainlink for Chainlink.Request;\n\n    // Chainlink variables\n    bytes32 private constant ORACLE_JOB_ID = \"79bf989ad07648c0a59bd679f366592d\";\n    uint256 private constant ORACLE_PAYMENT = (1 * LINK_DIVISIBILITY) / 10; // 0.1 LINK\n\n    // Declare the PromiseFactory contract address and the interface\n    address public s_promiseFactoryContract;\n    IPromiseFactory public s_promiseFactoryInterface;\n\n    // Variables returned by the oracle\n    string public s_username;\n    address public s_userAddress;\n    bool public s_verified = false;\n\n    // Events\n    event VerificationRequested(bytes32 indexed requestId, string username);\n    event VerificationFailed(bytes32 indexed requestId, string username);\n    event VerificationFulfilled(\n        bytes32 indexed requestId,\n        string username,\n        address userAddress,\n        bool verified\n    );\n\n    /**\n     * @notice Initialize the link token and target oracle\n     * Operator contract: 0x2BB8Dd9C16edeF313eb9ccBd5F42A8b577cB1E3c\n     * Link token: 0x326C977E6efc84E512bB9C30f76E30c160eD06FB\n     * Job ID: 79bf989a-d076-48c0-a59b-d679f366592d\n     */\n\n    // Another difference here: we don't need to pass the owner address to ConfirmedOwnerTestHelper\n    // We also need to pass the link token address and the oracle address to ChainlinkClientTestHelper\n    // Again, this is just needed for testing, to make sure it is correctly initialized\n    constructor(\n        address _linkTokenContract,\n        address _oracleContract,\n        address _promiseFactoryContract\n    )\n        ConfirmedOwnerTestHelper()\n        ChainlinkClientTestHelper(_linkTokenContract, _oracleContract)\n    {\n        setChainlinkToken(_linkTokenContract);\n        setChainlinkOracle(_oracleContract);\n        setPromiseFactoryContract(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Request a Twitter username to be verified\n     * @param _username The username to verify\n     */\n\n    function requestVerification(string memory _username)\n        public\n        returns (bytes32 requestId)\n    {\n        Chainlink.Request memory req = buildOperatorRequest(\n            ORACLE_JOB_ID,\n            this.fulfillVerification.selector\n        );\n        string memory userAddress = addressToString(msg.sender);\n\n        // Generate a signature with\n        // \"Verifying my Twitter account for ETH address <address>\" as the message\n        // It will prevent the signature from being passed as a parameter\n        string memory signature = string(\n            abi.encodePacked(\n                \"Verifying my Twitter account for ETH address \",\n                userAddress\n            )\n        );\n\n        req.add(\"username\", s_username);\n        req.add(\"signature\", signature);\n        req.add(\"address\", userAddress);\n        // req.add(\"copyPath1\", \"data,username\"); // username (string)\n        // req.add(\"copyPath2\", \"data,result\"); // verified (bool)\n        // req.add(\"copyPath3\", \"data,userAddress\"); // user address (msg.sender here) (address)\n        requestId = sendOperatorRequest(req, ORACLE_PAYMENT);\n\n        emit VerificationRequested(requestId, _username);\n    }\n\n    /**\n     * @notice Callback function used by the oracle to return the verification result\n     * @param _requestId The request ID\n     * @param _username The username to verify\n     * @param _verified The verification result\n     */\n\n    function fulfillVerification(\n        bytes32 _requestId,\n        string memory _username,\n        bool _verified,\n        address _userAddress\n    ) public recordChainlinkFulfillment(_requestId) {\n        s_username = _username;\n        s_userAddress = _userAddress;\n        s_verified = _verified;\n\n        if (_verified) {\n            // It's ok if the user already have a verified account, they can still verify another one\n            // Call the PromiseFactory contract to verify the user\n            // Which will map their address to their verified Twitter username(s)\n            s_promiseFactoryInterface.addTwitterVerifiedUser(\n                _userAddress,\n                _username\n            );\n\n            emit VerificationFulfilled(\n                _requestId,\n                _username,\n                _userAddress,\n                _verified\n            );\n        } else {\n            emit VerificationFailed(_requestId, _username);\n        }\n    }\n\n    /**\n     * @notice Call the promise factory contract to verify a Twitter account\n     * @dev It also sets the promise factory contract interface with this address\n     * @param _promiseFactoryContract The address of the PromiseFactory contract\n     */\n\n    function setPromiseFactoryContract(address _promiseFactoryContract)\n        public\n        onlyOwner\n    {\n        s_promiseFactoryContract = _promiseFactoryContract;\n        s_promiseFactoryInterface = IPromiseFactory(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Convert address to string\n     * @param _addr The address to convert\n     */\n\n    function addressToString(address _addr)\n        public\n        pure\n        returns (string memory)\n    {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = \"0\";\n        str[1] = \"x\";\n\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(str);\n    }\n\n    function getPromiseFactoryContract() public view returns (address) {\n        return s_promiseFactoryContract;\n    }\n\n    function getOraclePayment() public pure returns (uint256) {\n        return ORACLE_PAYMENT;\n    }\n}\n"
    },
    "contracts/tests/ChainlinkClientTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/tests/ChainlinkClientTestHelper.sol\";\n"
    },
    "contracts/tests/ConfirmedOwnerTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\";\n\ncontract ConfirmedOwnerTestHelper is ConfirmedOwner {\n    event Here();\n\n    constructor() ConfirmedOwner(msg.sender) {}\n\n    function modifierOnlyOwner() public onlyOwner {\n        emit Here();\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/tests/ChainlinkClientTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ChainlinkClient.sol\";\n\ncontract ChainlinkClientTestHelper is ChainlinkClient {\n  constructor(address _link, address _oracle) {\n    setChainlinkToken(_link);\n    setChainlinkOracle(_oracle);\n  }\n\n  event Request(bytes32 id, address callbackAddress, bytes4 callbackfunctionSelector, bytes data);\n  event LinkAmount(uint256 amount);\n\n  function publicNewRequest(\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature\n  ) public {\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    emit Request(req.id, req.callbackAddress, req.callbackFunctionId, req.buf.buf);\n  }\n\n  function publicRequest(\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    sendChainlinkRequest(req, _wei);\n  }\n\n  function publicRequestRunTo(\n    address _oracle,\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory run = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    sendChainlinkRequestTo(_oracle, run, _wei);\n  }\n\n  function publicRequestOracleData(\n    bytes32 _id,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory req = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\n    sendOperatorRequest(req, _wei);\n  }\n\n  function publicRequestOracleDataFrom(\n    address _oracle,\n    bytes32 _id,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory run = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\n    sendOperatorRequestTo(_oracle, run, _wei);\n  }\n\n  function publicCancelRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    bytes4 _callbackFunctionId,\n    uint256 _expiration\n  ) public {\n    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);\n  }\n\n  function publicChainlinkToken() public view returns (address) {\n    return chainlinkTokenAddress();\n  }\n\n  function publicFulfillChainlinkRequest(bytes32 _requestId, bytes32) public {\n    fulfillRequest(_requestId, bytes32(0));\n  }\n\n  function fulfillRequest(bytes32 _requestId, bytes32) public {\n    validateChainlinkCallback(_requestId);\n  }\n\n  function publicLINK(uint256 _amount) public {\n    emit LinkAmount(LINK_DIVISIBILITY * _amount);\n  }\n\n  function publicOracleAddress() public view returns (address) {\n    return chainlinkOracleAddress();\n  }\n\n  function publicAddExternalRequest(address _oracle, bytes32 _requestId) public {\n    addChainlinkExternalRequest(_oracle, _requestId);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "contracts/VerifyTwitter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\";\nimport \"./IPromiseFactory.sol\";\n\n/**\n * @notice Sends a request to the Chainlink oracle to verify a Twitter account\n * - The oracle will return the username, address, and verification status\n * - It uses a Chainlink node & an external adapter to interact with the Twitter API\n */\n\ncontract VerifyTwitter is ChainlinkClient, ConfirmedOwner {\n    using Chainlink for Chainlink.Request;\n\n    // Chainlink variables\n    bytes32 private constant ORACLE_JOB_ID = \"79bf989ad07648c0a59bd679f366592d\";\n    uint256 private constant ORACLE_PAYMENT = (1 * LINK_DIVISIBILITY) / 10; // 0.1 LINK\n\n    // Declare the PromiseFactory contract address and the interface\n    address public s_promiseFactoryContract;\n    IPromiseFactory public s_promiseFactoryInterface;\n\n    // Variables returned by the oracle\n    string public s_username;\n    address public s_userAddress;\n    bool public s_verified = false;\n\n    // Events\n    event VerificationRequested(bytes32 indexed requestId, string username);\n    event VerificationFailed(bytes32 indexed requestId, string username);\n    event VerificationFulfilled(\n        bytes32 indexed requestId,\n        string username,\n        address userAddress,\n        bool verified\n    );\n\n    /**\n     * @notice Initialize the link token and target oracle\n     * @param _linkTokenContract (Mumbai): 0x326C977E6efc84E512bB9C30f76E30c160eD06FB\n     * @param _oracleContract (Mumbai): 0x2BB8Dd9C16edeF313eb9ccBd5F42A8b577cB1E3c\n     * @param _promiseFactoryContract: The address of the PromiseFactory contract\n     * Job ID: 79bf989a-d076-48c0-a59b-d679f366592d\n     */\n\n    constructor(\n        address _linkTokenContract,\n        address _oracleContract,\n        address _promiseFactoryContract\n    ) ConfirmedOwner(msg.sender) {\n        setChainlinkToken(_linkTokenContract);\n        setChainlinkOracle(_oracleContract);\n        setPromiseFactoryContract(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Request a Twitter username to be verified\n     * @param _username The username to verify\n     */\n\n    function requestVerification(string memory _username)\n        public\n        returns (bytes32 requestId)\n    {\n        Chainlink.Request memory req = buildChainlinkRequest(\n            ORACLE_JOB_ID,\n            address(this),\n            this.fulfillVerification.selector\n        );\n        string memory userAddress = addressToString(msg.sender);\n\n        // Generate a signature with\n        // \"Verifying my Twitter account for ETH address <address>\" as the message\n        // It will prevent the signature from being passed as a parameter\n        string memory signature = string(\n            abi.encodePacked(\n                \"Verifying my Twitter account for ETH address \",\n                userAddress\n            )\n        );\n\n        req.add(\"username\", s_username);\n        req.add(\"signature\", signature);\n        req.add(\"address\", userAddress);\n        // req.add(\"copyPath1\", \"data,username\"); // username (string)\n        // req.add(\"copyPath2\", \"data,result\"); // verified (bool)\n        // req.add(\"copyPath3\", \"data,userAddress\"); // user address (msg.sender here) (address)\n        requestId = sendOperatorRequest(req, ORACLE_PAYMENT);\n\n        emit VerificationRequested(requestId, _username);\n    }\n\n    /**\n     * @notice Callback function used by the oracle to return the verification result\n     * @param _requestId The request ID\n     * @param _username The username to verify\n     * @param _verified The verification result\n     */\n\n    function fulfillVerification(\n        bytes32 _requestId,\n        string memory _username,\n        bool _verified,\n        address _userAddress\n    ) public recordChainlinkFulfillment(_requestId) {\n        s_username = _username;\n        s_userAddress = _userAddress;\n        s_verified = _verified;\n\n        if (_verified) {\n            // It's ok if the user already have a verified account, they can still verify another one\n            // Call the PromiseFactory contract to verify the user\n            // Which will map their address to their verified Twitter username(s)\n            s_promiseFactoryInterface.addTwitterVerifiedUser(\n                _userAddress,\n                _username\n            );\n\n            emit VerificationFulfilled(\n                _requestId,\n                _username,\n                _userAddress,\n                _verified\n            );\n        } else {\n            emit VerificationFailed(_requestId, _username);\n        }\n    }\n\n    /**\n     * @notice Call the promise factory contract to verify a Twitter account\n     * @dev It also sets the promise factory contract interface with this address\n     * @param _promiseFactoryContract The address of the PromiseFactory contract\n     */\n\n    function setPromiseFactoryContract(address _promiseFactoryContract)\n        public\n        onlyOwner\n    {\n        s_promiseFactoryContract = _promiseFactoryContract;\n        s_promiseFactoryInterface = IPromiseFactory(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Convert address to string\n     * @param _addr The address to convert\n     */\n\n    function addressToString(address _addr)\n        public\n        pure\n        returns (string memory)\n    {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = \"0\";\n        str[1] = \"x\";\n\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(str);\n    }\n\n    function getPromiseFactoryContract() public view returns (address) {\n        return s_promiseFactoryContract;\n    }\n\n    function getOraclePayment() public pure returns (uint256) {\n        return ORACLE_PAYMENT;\n    }\n}\n"
    },
    "contracts/PromiseContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @author polarzero\n * @title Promise Contract\n * @notice This is the child contract generated by the Promise Factory\n * once a user creates a new promise\n */\n\ncontract PromiseContract {\n    /// Errors\n    error PromiseContract__NOT_PARTICIPANT();\n    error PromiseContract__PROMISE_LOCKED();\n    error PromiseContract__approvePromise__ALREADY_APPROVED();\n    error PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();\n\n    /// Types\n    struct Participant {\n        string participantName;\n        string participantTwitterHandle;\n        address participantAddress;\n    }\n\n    /// Variables\n    uint256 public s_participantCount;\n    string public s_promiseName;\n    string public s_pdfUri;\n    address public immutable i_owner;\n    address[] public s_participantAddresses;\n    bool public s_promiseLocked = false;\n\n    // Mapping of addresses to name & twitter handle\n    mapping(address => Participant) public s_parties;\n    // Mapping of addresses to whether or not they have approved the agreement\n    mapping(address => bool) public s_approvedParties;\n\n    /// Events\n    event ParticipantCreated(\n        string participantName,\n        string participantTwitterHandle,\n        address indexed participantAddress\n    );\n\n    event ParticipantApproved(\n        string participantName,\n        string participantTwitterHandle,\n        address indexed participantAddress\n    );\n\n    event PromiseLocked();\n\n    /// Modifiers\n    modifier onlyParticipant() {\n        address[] memory participantAddresses = s_participantAddresses;\n        bool isParticipant = false;\n\n        // The owner will probably interact more with the contract\n        // So we can save some gas by checking it first\n        if (i_owner == msg.sender) {\n            isParticipant = true;\n        } else {\n            // Loop through the parties and check if the sender is a party\n            for (uint256 i = 0; i < s_participantCount; i++) {\n                if (participantAddresses[i] == msg.sender) {\n                    isParticipant = true;\n                    break;\n                }\n            }\n        }\n\n        if (!isParticipant) revert PromiseContract__NOT_PARTICIPANT();\n        _;\n    }\n\n    modifier onlyUnlocked() {\n        if (s_promiseLocked) revert PromiseContract__PROMISE_LOCKED();\n        _;\n    }\n\n    /// Functions\n    /**\n     * @dev Initialize the contract from the Master Contract with the user address as the owner\n     */\n\n    constructor(\n        address _owner,\n        string memory _promiseName,\n        string memory _pdfUri,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) {\n        i_owner = _owner;\n        s_promiseName = _promiseName;\n        s_pdfUri = _pdfUri;\n        s_participantCount = _partyAddresses.length;\n\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            _createParticipant(\n                _partyNames[i],\n                _partyTwitterHandles[i],\n                _partyAddresses[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Approve the promise as a participant\n     */\n\n    function approvePromise() public onlyParticipant onlyUnlocked {\n        if (s_approvedParties[msg.sender] == true) {\n            revert PromiseContract__approvePromise__ALREADY_APPROVED();\n        }\n\n        s_approvedParties[msg.sender] = true;\n        emit ParticipantApproved(\n            s_parties[msg.sender].participantName,\n            s_parties[msg.sender].participantTwitterHandle,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Validate the promise and lock it so that no more participants can change any state\n     * or even try to and lose gas\n     */\n\n    function lockPromise() public onlyParticipant onlyUnlocked {\n        address[] memory participantAddresses = s_participantAddresses;\n\n        // Loop through the parties and check if anyone has not approved yet\n        for (uint256 i = 0; i < s_participantCount; i++) {\n            if (s_approvedParties[participantAddresses[i]] == false) {\n                revert PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();\n            }\n        }\n\n        s_promiseLocked = true;\n        emit PromiseLocked();\n    }\n\n    /**\n     * @notice Create a new participant and add them to the mapping\n     * @dev This function can only be called during the contract creation\n     * @param _participantName The name of the participant\n     * @param _participantTwitterHandle The twitter handle of the participant\n     * @param _participantAddress The address of the participant\n     */\n\n    function _createParticipant(\n        string memory _participantName,\n        string memory _participantTwitterHandle,\n        address _participantAddress\n    ) private {\n        Participant memory participant = Participant(\n            _participantName,\n            _participantTwitterHandle,\n            _participantAddress\n        );\n        s_parties[_participantAddress] = participant;\n        s_participantAddresses.push(_participantAddress);\n\n        emit ParticipantCreated(\n            _participantName,\n            _participantTwitterHandle,\n            _participantAddress\n        );\n    }\n\n    /// Getters\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getName() public view returns (string memory) {\n        return s_promiseName;\n    }\n\n    function getPdfUri() public view returns (string memory) {\n        return s_pdfUri;\n    }\n\n    function getParticipant(address _participantAddress)\n        public\n        view\n        returns (Participant memory)\n    {\n        if (s_parties[_participantAddress].participantAddress == address(0)) {\n            revert PromiseContract__NOT_PARTICIPANT();\n        }\n\n        return s_parties[_participantAddress];\n    }\n\n    function getParticipantCount() public view returns (uint256) {\n        return s_participantCount;\n    }\n\n    function getParticipantAddresses() public view returns (address[] memory) {\n        return s_participantAddresses;\n    }\n\n    function getIsPromiseApproved(address _participantAddress)\n        public\n        view\n        returns (bool)\n    {\n        return s_approvedParties[_participantAddress];\n    }\n\n    function getIsPromiseLocked() public view returns (bool) {\n        return s_promiseLocked;\n    }\n}\n"
    },
    "contracts/PromiseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./PromiseContract.sol\";\n\n/**\n * @author polarzero\n * @title Master Contract\n * @notice This is the master contract initializing & referencing all child contracts\n */\n\ncontract PromiseFactory {\n    /// Errors\n    error PromiseFactory__createPromiseContract__EMPTY_FIELD();\n    error PromiseFactory__createPromiseContract__INCORRECT_FIELD_LENGTH();\n    error PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n    error PromiseFactory__createPromiseContract__INVALID_URI();\n    error PromiseFactory__NOT_OWNER();\n    error PromiseFactory__NOT_OPERATOR();\n\n    /// Variables\n    address public s_operator;\n\n    // Map the owner addresses to the child contracts they created\n    mapping(address => PromiseContract[]) public promiseContracts;\n\n    // Map the user addresses to their verified Twitter account(s)\n    mapping(address => string[]) public twitterVerifiedUsers;\n\n    /// Events\n    event PromiseContractCreated(\n        address indexed _owner,\n        address indexed _contractAddress,\n        string _promiseName,\n        string _pdfUri,\n        string[] _partyNames,\n        string[] _partyTwitterHandles,\n        address[] _partyAddresses\n    );\n\n    /// Modifiers\n    modifier onlyOwner() {\n        if (msg.sender != tx.origin) {\n            revert PromiseFactory__NOT_OWNER();\n        }\n        _;\n    }\n\n    modifier onlyOperator() {\n        if (msg.sender != s_operator) {\n            revert PromiseFactory__NOT_OPERATOR();\n        }\n        _;\n    }\n\n    /// Functions\n\n    /**\n     * @notice Initialize the contract\n     * @param _operator The operator address\n     */\n\n    constructor(address _operator) {\n        s_operator = _operator;\n    }\n\n    /**\n     * @notice Create a new contract and add it to the list of child contracts\n     * @param _promiseName The name of the contract specified by the user\n     * @param _pdfUri The URI of the PDF file stored on IPFS\n     * @param _partyNames The names of the parties specified by the user\n     * @param _partyTwitterHandles The Twitter handles of the parties specified by the user\n     * @param _partyAddresses The addresses specified by the user that will be allowed to interact\n     * with the contract\n     */\n\n    function createPromiseContract(\n        string memory _promiseName,\n        string memory _pdfUri,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) public returns (address promiseContractAddress) {\n        // Revert if one of the fields is empty\n        if (\n            !(bytes(_promiseName).length > 0 &&\n                bytes(_pdfUri).length > 0 &&\n                _partyNames.length > 0 &&\n                _partyAddresses.length > 0)\n        ) revert PromiseFactory__createPromiseContract__EMPTY_FIELD();\n\n        // Revert if the number of names, Twitter and addresses are not equal\n        // If Twitter handles are not provided, it will pass an empty string\n        if (\n            !(_partyAddresses.length == _partyTwitterHandles.length &&\n                _partyAddresses.length == _partyNames.length)\n        )\n            revert PromiseFactory__createPromiseContract__INCORRECT_FIELD_LENGTH();\n\n        // Revert if the same address or twitter handle is used twice\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            for (uint256 j = i + 1; j < _partyAddresses.length; j++) {\n                if (\n                    _partyAddresses[i] == _partyAddresses[j] ||\n                    keccak256(abi.encodePacked(_partyTwitterHandles[i])) ==\n                    keccak256(abi.encodePacked(_partyTwitterHandles[j]))\n                )\n                    revert PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n            }\n        }\n\n        // We could test the validity of the Twitter handles here, but it would not really matter\n        // since it won't have any value without being verified, and the verification already\n        // needs it to be valid\n\n        // Revert if the name of the promise is longer than 70 characters\n        if (bytes(_promiseName).length > 70) {\n            revert PromiseFactory__createPromiseContract__INCORRECT_FIELD_LENGTH();\n        }\n\n        // Check if the provided URI is a valid IPFS URI\n        bytes memory pdfUriBytes = bytes(_pdfUri);\n\n        // Minimum 5 bytes encoded in Base58 -> minimum 7 characters\n        if (!(pdfUriBytes.length > 6))\n            revert PromiseFactory__createPromiseContract__INVALID_URI();\n\n        // It should match the allowed characters in Base58\n        for (uint i = 0; i < pdfUriBytes.length; i++) {\n            if (\n                !(0x7ffeffe07ff7dfe03fe000000000000 &\n                    (uint(1) << uint8(pdfUriBytes[i])) >\n                    0)\n            ) {\n                revert PromiseFactory__createPromiseContract__INVALID_URI();\n            }\n        }\n\n        // Create a new contract for this promise\n        PromiseContract promiseContract = new PromiseContract(\n            msg.sender,\n            _promiseName,\n            _pdfUri,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n        promiseContracts[msg.sender].push(promiseContract);\n\n        emit PromiseContractCreated(\n            msg.sender,\n            address(promiseContract),\n            _promiseName,\n            _pdfUri,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n\n        return address(promiseContract);\n    }\n\n    /**\n     * @notice Add a verified Twitter account to the list of verified accounts\n     * @dev Only the operator contract can call this function, after the account\n     * has been verified with the Chainlink Node + External Adapter\n     * @param _userAddress The address of the user\n     * @param _twitterHandle The Twitter handle of the verified account\n     */\n\n    function addTwitterVerifiedUser(\n        address _userAddress,\n        string memory _twitterHandle\n    ) external onlyOperator {\n        // If the user address already has a verified account, add this one to the array\n        if (twitterVerifiedUsers[_userAddress].length > 0) {\n            twitterVerifiedUsers[_userAddress].push(_twitterHandle);\n        } else {\n            // If the user address doesn't have a verified account yet, create a new array\n            string[] memory usernames = new string[](1);\n            usernames[0] = _twitterHandle;\n            twitterVerifiedUsers[_userAddress] = usernames;\n        }\n    }\n\n    /// Setters\n    function setOperator(address _operator) external onlyOwner {\n        s_operator = _operator;\n    }\n\n    /// Getters\n    function getPromiseContractAddresses(address _owner)\n        public\n        view\n        returns (PromiseContract[] memory)\n    {\n        return promiseContracts[_owner];\n    }\n\n    function getPromiseContractCount(address _userAddress)\n        public\n        view\n        returns (uint256)\n    {\n        return promiseContracts[_userAddress].length;\n    }\n\n    function getTwitterVerifiedHandle(address _userAddress)\n        public\n        view\n        returns (string[] memory)\n    {\n        // Return the username if the user has a verified account\n        if (twitterVerifiedUsers[_userAddress].length > 0) {\n            return twitterVerifiedUsers[_userAddress];\n        } else {\n            // Return an empty array\n            string[] memory usernames = new string[](0);\n            return usernames;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}