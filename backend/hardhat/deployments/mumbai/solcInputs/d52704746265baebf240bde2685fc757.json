{
  "language": "Solidity",
  "sources": {
    "contracts/PromiseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./PromiseContract.sol\";\n\n/**\n * @author polarzero\n * @title Master Contract\n * @notice This is the master contract initializing & referencing all child contracts\n */\n\ncontract PromiseFactory {\n    /// Errors\n    error PromiseFactory__EMPTY_FIELD();\n    error PromiseFactory__INCORRECT_FIELD_LENGTH();\n    error PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n    error PromiseFactory__addParticipant__NOT_PARTICIPANT();\n    error PromiseFactory__addParticipant__ALREADY_PARTICIPANT();\n    error PromiseFactory__addTwitterVerifiedUser__ALREADY_VERIFIED();\n    error PromiseFactory__NOT_OWNER();\n    error PromiseFactory__NOT_VERIFIER();\n\n    /// Variables\n    address private immutable i_owner;\n    // The VerifyTwitter contract\n    address private s_verifier;\n\n    // Map the owner addresses to the child contracts they created\n    mapping(address => PromiseContract[]) private s_promiseContracts;\n\n    // Map the user addresses to their verified Twitter account(s)\n    mapping(address => string[]) private s_twitterVerifiedUsers;\n\n    /// Events\n    event PromiseContractCreated(\n        address indexed _owner,\n        address indexed _contractAddress,\n        string _promiseName,\n        string _ipfsCid,\n        string[] _partyNames,\n        string[] _partyTwitterHandles,\n        address[] _partyAddresses\n    );\n\n    event TwitterAddVerifiedSuccessful(\n        address indexed _owner,\n        string _twitterHandle\n    );\n\n    event TwitterAddVerifiedFailed(\n        address indexed _owner,\n        string _twitterHandle\n    );\n\n    event ParticipantAdded(\n        address indexed _contractAddress,\n        string _participantName,\n        string _participantTwitterHandle,\n        address _participantAddress\n    );\n\n    /// Modifiers\n    modifier onlyOwner() {\n        // msg sender should be the deployer of the contract\n        if (msg.sender != i_owner) {\n            revert PromiseFactory__NOT_OWNER();\n        }\n        _;\n    }\n\n    modifier onlyVerifier() {\n        if (msg.sender != s_verifier) {\n            revert PromiseFactory__NOT_VERIFIER();\n        }\n        _;\n    }\n\n    /// Functions\n\n    /**\n     * @notice Initialize the contract\n     */\n\n    constructor(address _verifier) {\n        i_owner = msg.sender;\n        s_verifier = _verifier;\n    }\n\n    /**\n     * @notice Create a new contract and add it to the list of child contracts\n     * @param _promiseName The name of the contract specified by the user\n     * @param _ipfsCid The CID of the directory stored on IPFS\n     * @param _partyNames The names of the parties specified by the user\n     * @param _partyTwitterHandles The Twitter handles of the parties specified by the user\n     * @param _partyAddresses The addresses specified by the user that will be allowed to interact\n     * with the contract\n     */\n\n    function createPromiseContract(\n        string memory _promiseName,\n        string memory _ipfsCid,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) public returns (address promiseContractAddress) {\n        // Revert if one of the fields is empty\n        if (\n            !(bytes(_promiseName).length > 0 &&\n                bytes(_ipfsCid).length > 0 &&\n                _partyNames.length > 0 &&\n                _partyTwitterHandles.length > 0 &&\n                _partyAddresses.length > 0)\n        ) revert PromiseFactory__EMPTY_FIELD();\n\n        // Revert if the number of names, Twitter and addresses are not equal\n        // If Twitter handles are not provided, it will pass an empty string\n        if (\n            !(_partyAddresses.length == _partyTwitterHandles.length &&\n                _partyAddresses.length == _partyNames.length)\n        ) revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n\n        // Revert if the same address or twitter handle is used twice\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            for (uint256 j = i + 1; j < _partyAddresses.length; j++) {\n                if (\n                    _partyAddresses[i] == _partyAddresses[j] ||\n                    keccak256(abi.encodePacked(_partyTwitterHandles[i])) ==\n                    keccak256(abi.encodePacked(_partyTwitterHandles[j]))\n                )\n                    revert PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n            }\n        }\n\n        // We could test the validity of the Twitter handles here, but it would not really matter\n        // since it won't have any value without being verified, and the verification already\n        // needs it to be valid\n\n        // Revert if the name of the promise is longer than 70 characters\n        if (bytes(_promiseName).length > 70) {\n            revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n        }\n        // Same for any of the party names but 30 characters\n        for (uint256 i = 0; i < _partyNames.length; i++) {\n            if (bytes(_partyNames[i]).length > 30) {\n                revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n            }\n        }\n        // We don't need to check the length of the Twitter handles\n        // If any were to be invalid, they would fail to get verified\n\n        // We can't make sure the provided CID is valid,\n        // because it could be provided either in a Base58 or Base32 format\n        // but it will be shown in the UI\n\n        // Create a new contract for this promise\n        PromiseContract promiseContract = new PromiseContract(\n            msg.sender,\n            _promiseName,\n            _ipfsCid,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n        s_promiseContracts[msg.sender].push(promiseContract);\n\n        emit PromiseContractCreated(\n            msg.sender,\n            address(promiseContract),\n            _promiseName,\n            _ipfsCid,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n\n        return address(promiseContract);\n    }\n\n    /**\n     * @notice Add a verified Twitter account to the list of verified accounts\n     * @dev Only the verifier contract can call this function, after the account\n     * has been verified with the Chainlink Node + External Adapter\n     * @param _userAddress The address of the user\n     * @param _twitterHandle The Twitter handle of the verified account\n     */\n\n    function addTwitterVerifiedUser(\n        address _userAddress,\n        string memory _twitterHandle\n    ) external onlyVerifier {\n        // If the user address doesn't have a verified account yet, create a new array\n        if (s_twitterVerifiedUsers[_userAddress].length == 0) {\n            s_twitterVerifiedUsers[_userAddress] = new string[](1);\n            // Add the verified account to the array\n            s_twitterVerifiedUsers[_userAddress][0] = _twitterHandle;\n        } else if (s_twitterVerifiedUsers[_userAddress].length > 0) {\n            string[] memory verifiedAccounts = s_twitterVerifiedUsers[\n                _userAddress\n            ];\n            for (uint256 i = 0; i < verifiedAccounts.length; i++) {\n                // If the user already verified this account, revert\n                if (\n                    keccak256(abi.encodePacked(verifiedAccounts[i])) ==\n                    keccak256(abi.encodePacked(_twitterHandle))\n                ) {\n                    revert PromiseFactory__addTwitterVerifiedUser__ALREADY_VERIFIED();\n                }\n            }\n            // But if it is not included, add it\n            s_twitterVerifiedUsers[_userAddress].push(_twitterHandle);\n            emit TwitterAddVerifiedSuccessful(_userAddress, _twitterHandle);\n        }\n    }\n\n    /**\n     * @notice Add a participant to a promise contract\n     * @dev Only a participant of the contract can call this function\n     * @dev It can only be called if the contract is not locked (the child contract takes care of that)\n     * @param _promiseContractAddress The address of the promise contract\n     * @param _partyName The name of the party\n     * @param _partyTwitterHandle The Twitter handle of the party\n     * @param _partyAddress The address of the party\n     */\n\n    function addParticipant(\n        address _promiseContractAddress,\n        string memory _partyName,\n        string memory _partyTwitterHandle,\n        address _partyAddress\n    ) public {\n        // Revert if one of the fields is empty\n        if (\n            !(bytes(_partyName).length > 0 &&\n                bytes(_partyTwitterHandle).length > 0)\n        ) revert PromiseFactory__EMPTY_FIELD();\n\n        // Revert if the sender is not a participant of the contract\n        if (\n            !PromiseContract(_promiseContractAddress).getIsParticipant(\n                msg.sender\n            )\n        ) {\n            revert PromiseFactory__addParticipant__NOT_PARTICIPANT();\n        }\n\n        // Revert if the user to add is already a participant of the contract\n        if (\n            PromiseContract(_promiseContractAddress).getIsParticipant(\n                _partyAddress\n            )\n        ) {\n            revert PromiseFactory__addParticipant__ALREADY_PARTICIPANT();\n        }\n\n        // Revert if the name of the party is longer than 30 characters\n        if (bytes(_partyName).length > 30) {\n            revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n        }\n\n        // Add the participant to the contract and emit an event if successful\n        PromiseContract(_promiseContractAddress).createParticipant(\n            _partyName,\n            _partyTwitterHandle,\n            _partyAddress\n        );\n\n        emit ParticipantAdded(\n            _promiseContractAddress,\n            _partyName,\n            _partyTwitterHandle,\n            _partyAddress\n        );\n    }\n\n    /// Setters\n    function setVerifier(address _verifier) external onlyOwner {\n        s_verifier = _verifier;\n    }\n\n    /// Getters\n    function getPromiseContractAddresses(address _owner)\n        public\n        view\n        returns (PromiseContract[] memory)\n    {\n        return s_promiseContracts[_owner];\n    }\n\n    function getPromiseContractCount(address _userAddress)\n        public\n        view\n        returns (uint256)\n    {\n        return s_promiseContracts[_userAddress].length;\n    }\n\n    function getTwitterVerifiedHandle(address _userAddress)\n        public\n        view\n        returns (string[] memory)\n    {\n        // Return the username if the user has a verified account\n        if (s_twitterVerifiedUsers[_userAddress].length > 0) {\n            return s_twitterVerifiedUsers[_userAddress];\n        } else {\n            // Return an empty array\n            string[] memory usernames = new string[](0);\n            return usernames;\n        }\n    }\n\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getVerifier() public view returns (address) {\n        return s_verifier;\n    }\n}\n"
    },
    "contracts/PromiseContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @author polarzero\n * @title Promise Contract\n * @notice This is the child contract generated by the Promise Factory\n * once a user creates a new promise\n */\n\ncontract PromiseContract {\n    /// Errors\n    error PromiseContract__NOT_FACTORY();\n    error PromiseContract__NOT_PARTICIPANT();\n    error PromiseContract__PROMISE_LOCKED();\n    error PromiseContract__approvePromise__ALREADY_APPROVED();\n    error PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();\n\n    /// Types\n    struct Participant {\n        string participantName;\n        string participantTwitterHandle;\n        address participantAddress;\n    }\n\n    /// Variables\n    uint256 private s_participantCount;\n    string private s_promiseName;\n    string private s_ipfsCid;\n    address private immutable i_owner;\n    address private immutable i_promiseFactoryContract;\n    address[] private s_participantAddresses;\n    bool private s_promiseLocked = false;\n\n    // Mapping of addresses to name & twitter handle\n    mapping(address => Participant) private s_parties;\n    // Mapping of addresses to whether or not they have approved the agreement\n    mapping(address => bool) private s_approvedParties;\n\n    /// Events\n    event ParticipantCreated(\n        string participantName,\n        string participantTwitterHandle,\n        address indexed participantAddress\n    );\n\n    event ParticipantApproved(\n        string participantName,\n        string participantTwitterHandle,\n        address indexed participantAddress\n    );\n\n    event PromiseLocked();\n\n    /// Modifiers\n    modifier onlyParticipant() {\n        bool isParticipant = getIsParticipant(msg.sender);\n\n        if (!isParticipant) revert PromiseContract__NOT_PARTICIPANT();\n        _;\n    }\n\n    modifier onlyUnlocked() {\n        if (s_promiseLocked) revert PromiseContract__PROMISE_LOCKED();\n        _;\n    }\n\n    modifier onlyPromiseFactory() {\n        if (msg.sender != i_promiseFactoryContract)\n            revert PromiseContract__NOT_FACTORY();\n        _;\n    }\n\n    /// Functions\n    /**\n     * @dev Initialize the contract from the Master Contract with the user address as the owner\n     */\n\n    constructor(\n        address _owner,\n        string memory _promiseName,\n        string memory _ipfsCid,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) {\n        i_promiseFactoryContract = msg.sender;\n        i_owner = _owner;\n        s_promiseName = _promiseName;\n        s_ipfsCid = _ipfsCid;\n        s_participantCount = _partyAddresses.length;\n\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            createParticipant(\n                _partyNames[i],\n                _partyTwitterHandles[i],\n                _partyAddresses[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Approve the promise as a participant\n     */\n\n    function approvePromise() public onlyParticipant onlyUnlocked {\n        if (s_approvedParties[msg.sender] == true) {\n            revert PromiseContract__approvePromise__ALREADY_APPROVED();\n        }\n\n        s_approvedParties[msg.sender] = true;\n        emit ParticipantApproved(\n            s_parties[msg.sender].participantName,\n            s_parties[msg.sender].participantTwitterHandle,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Validate the promise and lock it so that no more participants can change any state\n     * or even try to and lose gas\n     */\n\n    function lockPromise() public onlyParticipant onlyUnlocked {\n        address[] memory participantAddresses = s_participantAddresses;\n\n        // Loop through the parties and check if anyone has not approved yet\n        for (uint256 i = 0; i < s_participantCount; i++) {\n            if (s_approvedParties[participantAddresses[i]] == false) {\n                revert PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();\n            }\n        }\n\n        s_promiseLocked = true;\n        emit PromiseLocked();\n    }\n\n    /**\n     * @notice Create a new participant and add them to the mapping\n     * @dev This function can only be called by the Promise Factory\n     * @param _participantName The name of the participant\n     * @param _participantTwitterHandle The twitter handle of the participant\n     * @param _participantAddress The address of the participant\n     */\n\n    function createParticipant(\n        string memory _participantName,\n        string memory _participantTwitterHandle,\n        address _participantAddress\n    ) public onlyPromiseFactory onlyUnlocked {\n        Participant memory participant = Participant(\n            _participantName,\n            _participantTwitterHandle,\n            _participantAddress\n        );\n        s_parties[_participantAddress] = participant;\n        s_participantAddresses.push(_participantAddress);\n\n        emit ParticipantCreated(\n            _participantName,\n            _participantTwitterHandle,\n            _participantAddress\n        );\n    }\n\n    /// Getters\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getName() public view returns (string memory) {\n        return s_promiseName;\n    }\n\n    function getIpfsCid() public view returns (string memory) {\n        return s_ipfsCid;\n    }\n\n    function getParticipant(address _address)\n        public\n        view\n        returns (Participant memory)\n    {\n        return s_parties[_address];\n    }\n\n    function getIsParticipant(address _participantAddress)\n        public\n        view\n        returns (bool)\n    {\n        if (s_parties[_participantAddress].participantAddress == address(0)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function getParticipantCount() public view returns (uint256) {\n        return s_participantCount;\n    }\n\n    function getIsPromiseApproved(address _participantAddress)\n        public\n        view\n        returns (bool)\n    {\n        return s_approvedParties[_participantAddress];\n    }\n\n    function getIsPromiseLocked() public view returns (bool) {\n        return s_promiseLocked;\n    }\n\n    function getPromiseFactoryContract() public view returns (address) {\n        return i_promiseFactoryContract;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}