{
  "language": "Solidity",
  "sources": {
    "contracts/IPromiseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IPromiseFactory {\n    function addTwitterVerifiedUser(\n        address _userAddress,\n        string memory _username\n    ) external;\n\n    function updateStorageStatus(\n        address _promiseContractAddress,\n        uint8 _storageStatus\n    ) external;\n}\n"
    },
    "contracts/VerifyTwitter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\";\nimport \"./IPromiseFactory.sol\";\nimport \"./utils/AddressToString.sol\";\n\n/**\n * @author polarzero\n * @title VerifyTwitter\n * @notice Sends a request to the Chainlink oracle to verify a Twitter account\n * - The oracle will return the username, address, and verification status\n * - It uses a Chainlink node & an external adapter to interact with the Twitter API\n */\n\ncontract VerifyTwitter is ChainlinkClient, ConfirmedOwner {\n    using Chainlink for Chainlink.Request;\n\n    // Chainlink variables\n    uint256 private constant ORACLE_PAYMENT = (1 * LINK_DIVISIBILITY) / 10; // 0.1 LINK\n    bytes32 private s_oracleJobId = \"b6ddd15e02e84e3cb8840f75c7658ba8\";\n\n    // Declare the PromiseFactory contract address and the interface\n    address private s_promiseFactoryContract;\n    IPromiseFactory private s_promiseFactoryInterface;\n\n    // Events\n    event VerificationRequested(bytes32 indexed requestId, string username);\n    event VerificationFailed(bytes32 indexed requestId, string username);\n    event VerificationSuccessful(\n        bytes32 indexed requestId,\n        string username,\n        address userAddress,\n        bool verified\n    );\n\n    /**\n     * @notice Initialize the link token and target oracle\n     * @param _linkTokenContract (Mumbai): 0x326C977E6efc84E512bB9C30f76E30c160eD06FB\n     * @param _oracleContract (Mumbai): 0x2BB8Dd9C16edeF313eb9ccBd5F42A8b577cB1E3c\n     * @param _promiseFactoryContract: The address of the PromiseFactory contract\n     */\n\n    constructor(\n        address _linkTokenContract,\n        address _oracleContract,\n        address _promiseFactoryContract\n    ) ConfirmedOwner(msg.sender) {\n        setChainlinkToken(_linkTokenContract);\n        setChainlinkOracle(_oracleContract);\n        setPromiseFactoryContract(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Request a Twitter username to be verified\n     * @param _username The username to verify\n     */\n\n    function requestVerification(string memory _username)\n        public\n        returns (bytes32 requestId)\n    {\n        Chainlink.Request memory req = buildChainlinkRequest(\n            s_oracleJobId,\n            address(this),\n            this.fulfillVerification.selector\n        );\n        string memory userAddress = addressToString(msg.sender);\n\n        req.add(\"username\", _username);\n        req.add(\"address\", userAddress);\n        requestId = sendOperatorRequest(req, ORACLE_PAYMENT);\n\n        emit VerificationRequested(requestId, _username);\n    }\n\n    /**\n     * @notice Callback function used by the oracle to return the verification result\n     * @param _requestId The request ID\n     * @param _username The username to verify\n     * @param _verified The verification result\n     */\n\n    function fulfillVerification(\n        bytes32 _requestId,\n        string memory _username,\n        bool _verified,\n        address _userAddress\n    ) external recordChainlinkFulfillment(_requestId) {\n        if (_verified) {\n            // It's ok if the user already have a verified account, they can still verify another one\n            // Call the PromiseFactory contract to verify the user\n            // Which will map their address to their verified Twitter username(s)\n            s_promiseFactoryInterface.addTwitterVerifiedUser(\n                _userAddress,\n                _username\n            );\n\n            emit VerificationSuccessful(\n                _requestId,\n                _username,\n                _userAddress,\n                _verified\n            );\n        } else {\n            emit VerificationFailed(_requestId, _username);\n        }\n    }\n\n    /**\n     * @notice Set the address of the PromiseFactory contract\n     * @param _promiseFactoryContract: The address of the PromiseFactory contract\n     */\n\n    function setPromiseFactoryContract(address _promiseFactoryContract)\n        public\n        onlyOwner\n    {\n        s_promiseFactoryContract = _promiseFactoryContract;\n        s_promiseFactoryInterface = IPromiseFactory(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Set the oracle job ID\n     * @param _oracleJobId The oracle job ID\n     */\n\n    function setOracleJobId(bytes32 _oracleJobId) public onlyOwner {\n        s_oracleJobId = _oracleJobId;\n    }\n\n    // Getters\n\n    function getPromiseFactoryContract() public view returns (address) {\n        return s_promiseFactoryContract;\n    }\n\n    function getOracleJobId() public view returns (bytes32) {\n        return s_oracleJobId;\n    }\n\n    function getOraclePayment() public pure returns (uint256) {\n        return ORACLE_PAYMENT;\n    }\n\n    function getLinkBalance() public view returns (uint256) {\n        LinkTokenInterface linkToken = LinkTokenInterface(\n            chainlinkTokenAddress()\n        );\n        return linkToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/utils/AddressToString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @notice Convert address to string\n * @param _addr The address to convert\n */\n\nfunction addressToString(address _addr) pure returns (string memory) {\n    bytes32 value = bytes32(uint256(uint160(_addr)));\n    bytes memory alphabet = \"0123456789abcdef\";\n    bytes memory str = new bytes(42);\n    str[0] = \"0\";\n    str[1] = \"x\";\n\n    for (uint256 i = 0; i < 20; i++) {\n        str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n        str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n    }\n\n    return string(str);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/tests/ChainlinkClientTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ChainlinkClient.sol\";\n\ncontract ChainlinkClientTestHelper is ChainlinkClient {\n  constructor(address _link, address _oracle) {\n    setChainlinkToken(_link);\n    setChainlinkOracle(_oracle);\n  }\n\n  event Request(bytes32 id, address callbackAddress, bytes4 callbackfunctionSelector, bytes data);\n  event LinkAmount(uint256 amount);\n\n  function publicNewRequest(\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature\n  ) public {\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    emit Request(req.id, req.callbackAddress, req.callbackFunctionId, req.buf.buf);\n  }\n\n  function publicRequest(\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    sendChainlinkRequest(req, _wei);\n  }\n\n  function publicRequestRunTo(\n    address _oracle,\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory run = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    sendChainlinkRequestTo(_oracle, run, _wei);\n  }\n\n  function publicRequestOracleData(\n    bytes32 _id,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory req = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\n    sendOperatorRequest(req, _wei);\n  }\n\n  function publicRequestOracleDataFrom(\n    address _oracle,\n    bytes32 _id,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory run = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\n    sendOperatorRequestTo(_oracle, run, _wei);\n  }\n\n  function publicCancelRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    bytes4 _callbackFunctionId,\n    uint256 _expiration\n  ) public {\n    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);\n  }\n\n  function publicChainlinkToken() public view returns (address) {\n    return chainlinkTokenAddress();\n  }\n\n  function publicFulfillChainlinkRequest(bytes32 _requestId, bytes32) public {\n    fulfillRequest(_requestId, bytes32(0));\n  }\n\n  function fulfillRequest(bytes32 _requestId, bytes32) public {\n    validateChainlinkCallback(_requestId);\n  }\n\n  function publicLINK(uint256 _amount) public {\n    emit LinkAmount(LINK_DIVISIBILITY * _amount);\n  }\n\n  function publicOracleAddress() public view returns (address) {\n    return chainlinkOracleAddress();\n  }\n\n  function publicAddExternalRequest(address _oracle, bytes32 _requestId) public {\n    addChainlinkExternalRequest(_oracle, _requestId);\n  }\n}\n"
    },
    "contracts/tests/ChainlinkClientTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/tests/ChainlinkClientTestHelper.sol\";\n"
    },
    "contracts/MockVerifyTwitter.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// Make sure it is compatible with all ^0.7.0, ^0.8.0 and ^0.8.16\npragma solidity ^0.8.0;\n\nimport \"./tests/ChainlinkClientTestHelper.sol\";\nimport \"./tests/ConfirmedOwnerTestHelper.sol\";\nimport \"./IPromiseFactory.sol\";\nimport \"./utils/AddressToString.sol\";\n\n/**\n * @author polarzero\n * @title MockVerifyTwitter\n * @notice This contract is used to test the VerifyTwitter contract\n * The functions are the same, but they don't actually send data to the operator\n * We make use of the ChainlinkClientTestHelper contract to mock the ChainlinkClient\n * as well as the ConfirmedOwnerTestHelper contract to mock the ConfirmedOwner\n * They provide additional functions to test that the contract is correctly initialized\n */\n\ncontract MockVerifyTwitter is\n    ChainlinkClientTestHelper,\n    ConfirmedOwnerTestHelper\n{\n    using Chainlink for Chainlink.Request;\n\n    // Chainlink variables\n    uint256 private constant ORACLE_PAYMENT = (1 * LINK_DIVISIBILITY) / 10; // 0.1 LINK\n    bytes32 private s_oracleJobId = \"b6ddd15e02e84e3cb8840f75c7658ba8\";\n\n    // Declare the PromiseFactory contract address and the interface\n    address private s_promiseFactoryContract;\n    IPromiseFactory private s_promiseFactoryInterface;\n\n    // Events\n    event VerificationRequested(bytes32 indexed requestId, string username);\n    event VerificationFailed(bytes32 indexed requestId, string username);\n    event VerificationSuccessful(\n        bytes32 indexed requestId,\n        string username,\n        address userAddress,\n        bool verified\n    );\n\n    /**\n     * @notice Initialize the link token and target oracle\n     * @param _linkTokenContract (Mumbai): 0x326C977E6efc84E512bB9C30f76E30c160eD06FB\n     * @param _oracleContract ! Not the true oracle contract, but the address we own\n     * @param _promiseFactoryContract: The address of the PromiseFactory contract\n     * Operator contract: 0x2BB8Dd9C16edeF313eb9ccBd5F42A8b577cB1E3c\n     * Job ID: 79bf989a-d076-48c0-a59b-d679f366592d\n     */\n\n    // Another difference here: we don't need to pass the owner address to ConfirmedOwnerTestHelper\n    // We also need to pass the link token address and the oracle address to ChainlinkClientTestHelper\n    // Again, this is just needed for testing, to make sure it is correctly initialized\n    constructor(\n        address _linkTokenContract,\n        // In this mock, we're passing an address we own as the oracle address\n        // so we can test the fulfill function\n        address _oracleContract,\n        address _promiseFactoryContract\n    )\n        ConfirmedOwnerTestHelper()\n        ChainlinkClientTestHelper(_linkTokenContract, _oracleContract)\n    {\n        setChainlinkToken(_linkTokenContract);\n        setChainlinkOracle(_oracleContract);\n        setPromiseFactoryContract(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Request a Twitter username to be verified\n     * @param _username The username to verify\n     */\n\n    function requestVerification(string memory _username)\n        public\n        returns (bytes32 requestId)\n    {\n        // ! This should be called by Chainlink when building the request\n        // ! It would associate the requestId with the operator address\n        // ! ... which prevents anyone else from calling the fulfill function\n        // ! We're doing it here only for testing purposes, so we can trigger it manually\n        requestId = \"0x1234567890\";\n        publicAddExternalRequest(msg.sender, requestId);\n        emit VerificationRequested(requestId, _username);\n    }\n\n    /**\n     * @notice Callback function used by the oracle to return the verification result\n     * @param _requestId The request ID\n     * @param _username The username to verify\n     * @param _verified The verification result\n     */\n\n    function fulfillVerification(\n        bytes32 _requestId,\n        string memory _username,\n        bool _verified,\n        address _userAddress\n    ) external recordChainlinkFulfillment(_requestId) {\n        if (_verified) {\n            // It's ok if the user already have a verified account, they can still verify another one\n            // Call the PromiseFactory contract to verify the user\n            // Which will map their address to their verified Twitter username(s)\n            s_promiseFactoryInterface.addTwitterVerifiedUser(\n                _userAddress,\n                _username\n            );\n\n            emit VerificationSuccessful(\n                _requestId,\n                _username,\n                _userAddress,\n                _verified\n            );\n        } else {\n            emit VerificationFailed(_requestId, _username);\n        }\n    }\n\n    function setPromiseFactoryContract(address _promiseFactoryContract)\n        public\n        onlyOwner\n    {\n        s_promiseFactoryContract = _promiseFactoryContract;\n        s_promiseFactoryInterface = IPromiseFactory(_promiseFactoryContract);\n    }\n\n    function getPromiseFactoryContract() public view returns (address) {\n        return s_promiseFactoryContract;\n    }\n\n    function getOraclePayment() public pure returns (uint256) {\n        return ORACLE_PAYMENT;\n    }\n\n    // Additional function to test 'addressToString'\n    function testAddressToString(address _address)\n        public\n        pure\n        returns (string memory)\n    {\n        return addressToString(_address);\n    }\n}\n"
    },
    "contracts/tests/ConfirmedOwnerTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\";\n\ncontract ConfirmedOwnerTestHelper is ConfirmedOwner {\n    event Here();\n\n    constructor() ConfirmedOwner(msg.sender) {}\n\n    function modifierOnlyOwner() public onlyOwner {\n        emit Here();\n    }\n}\n"
    },
    "contracts/VerifyStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\";\nimport \"./IPromiseFactory.sol\";\nimport \"./utils/AddressToString.sol\";\n\n// storageStatus = 0 -> the provided IPFS and Arweave hashes have not yet been verified\n// storageStatus = 1 -> the provided IPFS and eventually Arweave hashes could not be verified\n// storageStatus = 2 -> only the IPFS hash has been provided and verified\n// storageStatus = 3 -> both the IPFS & Arweave hashes has been provided and verified\n\n/**\n * @author polarzero\n * @title VerifyStorage\n * @notice Sends a request to the Chainlink oracle to verify the IPFS & Arweave hashes\n * of a promise contract\n * - If the promise has been created through the website, a string containing the user address,\n * the IPFS hash and the Arweave ID will be encrypted along with a secret key and sent with the\n * contract creation arguments. It will be decrypted by making a request to the Chainlink Node,\n * with the help of an external adapter. The latter will decrypt the string and verify it does\n * indeed contain the correct IPFS & Arweave hashes.\n * -> It allows us to make sure the promise links to a permanent storage for the content, and\n * that this content is the one the user uploaded to both platforms.\n * - The users can still create promises without using the website, in which case the hashes\n * will be sent as arguments to the contract constructor. In this case, the oracle will simply\n * not be able to verify the hashes, therefore the website will not be able to display a 'verified'\n * badge.\n */\n\ncontract VerifyStorage is ChainlinkClient, ConfirmedOwner {\n    using Chainlink for Chainlink.Request;\n\n    error VerifyStorage__NOT_FACTORY();\n\n    // Chainlink variables\n    uint256 private constant ORACLE_PAYMENT = (1 * LINK_DIVISIBILITY) / 10; // 0.1 LINK\n    bytes32 private s_oracleJobId = \"cd430ded65b64b5fae032f9b9b37b89d\";\n\n    // Declare the PromiseFactory contract address and the interface\n    address private s_promiseFactoryContract;\n    IPromiseFactory private s_promiseFactoryInterface;\n\n    // Events\n    event StorageStatusUpdateRequested(\n        bytes32 indexed requestId,\n        address indexed promiseAddress\n    );\n    event StorageStatusUpdateSuccessful(\n        bytes32 indexed requestId,\n        address indexed promiseAddress,\n        uint8 storageStatus\n    );\n\n    // Modifier to check if the caller is the PromiseFactory contract\n    modifier onlyPromiseFactory() {\n        if (msg.sender != s_promiseFactoryContract)\n            revert VerifyStorage__NOT_FACTORY();\n        _;\n    }\n\n    /**\n     * @notice Initialize the link token and target oracle\n     * @param _linkTokenContract (Mumbai): 0x326C977E6efc84E512bB9C30f76E30c160eD06FB\n     * @param _oracleContract (Mumbai): 0x2BB8Dd9C16edeF313eb9ccBd5F42A8b577cB1E3c\n     * @param _promiseFactoryContract: The address of the PromiseFactory contract\n     */\n\n    constructor(\n        address _linkTokenContract,\n        address _oracleContract,\n        address _promiseFactoryContract\n    ) ConfirmedOwner(msg.sender) {\n        setChainlinkToken(_linkTokenContract);\n        setChainlinkOracle(_oracleContract);\n        setPromiseFactoryContract(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Request a promise storage status to be updated\n     * @param _promiseAddress The address of the promise contract\n     * @param _userAddress The address of the user who created the promise\n     * @param _ipfsCid The IPFS CID of the promise content\n     * @param _arweaveId The Arweave ID of the promise content\n     * @param _encryptedProof The encrypted string containing the user address, the IPFS hash\n     * and the Arweave ID\n     * @dev Only the PromiseFactory contract can call this function (it will after\n     * creating a new promise)\n     */\n\n    function requestStorageStatusUpdate(\n        address _promiseAddress,\n        address _userAddress,\n        string memory _ipfsCid,\n        string memory _arweaveId,\n        string memory _encryptedProof\n    ) external onlyPromiseFactory returns (bytes32 requestId) {\n        Chainlink.Request memory req = buildChainlinkRequest(\n            s_oracleJobId,\n            address(this),\n            this.fulfillStorageStatusUpdate.selector\n        );\n\n        string memory promiseAddress = addressToString(_promiseAddress);\n        string memory userAddress = addressToString(_userAddress);\n\n        req.add(\"promiseAddress\", promiseAddress);\n        req.add(\"userAddress\", userAddress);\n        req.add(\"ipfsCid\", _ipfsCid);\n        req.add(\"arweaveId\", _arweaveId);\n        req.add(\"encryptedProof\", _encryptedProof);\n\n        requestId = sendOperatorRequest(req, ORACLE_PAYMENT);\n        emit StorageStatusUpdateRequested(requestId, _promiseAddress);\n    }\n\n    /**\n     * @notice Callback function used by the oracleto return the promise storage status\n     * @param _requestId The request ID\n     * @param _promiseAddress The address of the promise contract\n     * @param _backupStatus The storage status of the promise\n     * -> We're receiving _backupStatus instead of _storageStatus because the Node is\n     * confused about that _storage keyword, so it's better to change it only in that job.\n     * @dev Only the Chainlink oracle can call this function\n     */\n\n    function fulfillStorageStatusUpdate(\n        bytes32 _requestId,\n        address _promiseAddress,\n        uint8 _backupStatus\n    ) external recordChainlinkFulfillment(_requestId) {\n        s_promiseFactoryInterface.updateStorageStatus(\n            _promiseAddress,\n            _backupStatus\n        );\n\n        emit StorageStatusUpdateSuccessful(\n            _requestId,\n            _promiseAddress,\n            _backupStatus\n        );\n    }\n\n    /**\n     * @notice Set the address of the PromiseFactory contract\n     * @param _promiseFactoryContract: The address of the PromiseFactory contract\n     */\n\n    function setPromiseFactoryContract(address _promiseFactoryContract)\n        public\n        onlyOwner\n    {\n        s_promiseFactoryContract = _promiseFactoryContract;\n        s_promiseFactoryInterface = IPromiseFactory(_promiseFactoryContract);\n    }\n\n    /**\n     * @notice Set the oracle job ID\n     * @param _oracleJobId The oracle job ID\n     */\n\n    function setOracleJobId(bytes32 _oracleJobId) public onlyOwner {\n        s_oracleJobId = _oracleJobId;\n    }\n\n    // Getters\n\n    function getPromiseFactoryContract() public view returns (address) {\n        return s_promiseFactoryContract;\n    }\n\n    function getOracleJobId() public view returns (bytes32) {\n        return s_oracleJobId;\n    }\n\n    function getOraclePayment() public pure returns (uint256) {\n        return ORACLE_PAYMENT;\n    }\n\n    function getLinkBalance() public view returns (uint256) {\n        LinkTokenInterface linkToken = LinkTokenInterface(\n            chainlinkTokenAddress()\n        );\n        return linkToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/MockVerifyStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./tests/ChainlinkClientTestHelper.sol\";\nimport \"./tests/ConfirmedOwnerTestHelper.sol\";\nimport \"./IPromiseFactory.sol\";\nimport \"./utils/AddressToString.sol\";\n\n/**\n * @author polarzero\n * @title MockVerifyStorage\n * @notice This contract is used to test the VerifyStorage contract\n * The functions are the same, but they don't actually send data to the operator\n * We make use of the ChainlinkClientTestHelper contract to mock the ChainlinkClient\n * as well as the ConfirmedOwnerTestHelper contract to mock the ConfirmedOwner\n * They provide additional functions to test that the contract is correctly initialized\n */\n\ncontract MockVerifyStorage is\n    ChainlinkClientTestHelper,\n    ConfirmedOwnerTestHelper\n{\n    using Chainlink for Chainlink.Request;\n\n    error VerifyStorage__NOT_FACTORY();\n\n    // Chainlink variables\n    uint256 private constant ORACLE_PAYMENT = (1 * LINK_DIVISIBILITY) / 10; // 0.1 LINK\n    bytes32 private s_oracleJobId = \"6b8a5d182e2640999421f57e9c0a1d4e\";\n\n    // Declare the PromiseFactory contract address and the interface\n    address private s_promiseFactoryContract;\n    IPromiseFactory private s_promiseFactoryInterface;\n    address private s_fakePromiseFactoryContract;\n\n    // Events\n    event StorageStatusUpdateRequested(\n        bytes32 indexed requestId,\n        address indexed contractAddress\n    );\n\n    // For testing purposes\n    event StorageStatusUpdateRequestedVerifyArguments(\n        address promiseAddress,\n        address userAddress,\n        string ipfsCid,\n        string arweaveId,\n        string encryptedProof\n    );\n\n    event StorageStatusUpdateSuccessful(\n        bytes32 indexed requestId,\n        address indexed contractAddress,\n        uint8 storageStatus\n    );\n\n    // Modifier to check if the caller is the PromiseFactory contract\n    modifier onlyPromiseFactory() {\n        if (msg.sender != s_fakePromiseFactoryContract)\n            revert VerifyStorage__NOT_FACTORY();\n        _;\n    }\n\n    /**\n     * @notice Initialize the link token and target oracle\n     * @param _linkTokenContract (Mumbai): 0x326C977E6efc84E512bB9C30f76E30c160eD06FB\n     * @param _oracleContract ! Not the true oracle contract, but the address we own\n     * @param _promiseFactoryContract: The address of the PromiseFactory contract\n     * @param _fakePromiseFactoryContract: The address of the fake PromiseFactory contract\n     * -> It will allow us to pretend we are the PromiseFactory during unit tests\n     */\n\n    // Differences from the real contract:\n    // We don't need to pass the owner address to ConfirmedOwnerTestHelper\n    // But need to pass the link token address and the oracle address to ChainlinkClientTestHelper\n    // We are passing a fake address that we own as the oracle, to be able to fulfill requests\n    // We do the same for the promise factory contract, to test the onlyFactory modifier\n    constructor(\n        address _linkTokenContract,\n        address _oracleContract,\n        address _promiseFactoryContract,\n        address _fakePromiseFactoryContract\n    )\n        ConfirmedOwnerTestHelper()\n        ChainlinkClientTestHelper(_linkTokenContract, _oracleContract)\n    {\n        setChainlinkToken(_linkTokenContract);\n        setChainlinkOracle(_oracleContract);\n        setPromiseFactoryContract(_promiseFactoryContract);\n        s_fakePromiseFactoryContract = _fakePromiseFactoryContract;\n    }\n\n    /**\n     * @notice Request a promise storage status to be updated\n     * @param _promiseAddress The address of the promise contract\n     * @param _userAddress The address of the user who created the promise\n     * @param _ipfsCid The IPFS CID of the promise content\n     * @param _arweaveId The Arweave ID of the promise content\n     * @param _encryptedProof The encrypted string containing the user address, the IPFS hash\n     * and the Arweave ID\n     * @dev Only the PromiseFactory contract can call this function (it will after\n     * creating a new promise)\n     */\n\n    function requestStorageStatusUpdate(\n        address _promiseAddress,\n        address _userAddress,\n        string memory _ipfsCid,\n        string memory _arweaveId,\n        string memory _encryptedProof\n    ) external onlyPromiseFactory returns (bytes32 requestId) {\n        // We don't make the request to the oracle here\n        // But we are hardcoding the requestId for testing purpose\n        // ! This is absolutely not how it should be done in production\n        // ! This should be called by Chainlink when building the request\n        // ! It would associate the requestId with the operator address\n        // ! ... which prevents anyone else from calling the fulfill function\n        requestId = \"0x1234567890\";\n        publicAddExternalRequest(msg.sender, requestId);\n\n        emit StorageStatusUpdateRequested(requestId, _promiseAddress);\n        // Only for testing purposes\n        emit StorageStatusUpdateRequestedVerifyArguments(\n            _promiseAddress,\n            _userAddress,\n            _ipfsCid,\n            _arweaveId,\n            _encryptedProof\n        );\n    }\n\n    /**\n     * @notice Callback function used by the oracleto return the promise storage status\n     * @param _requestId The request ID\n     * @param _promiseAddress The address of the promise contract\n     * @param _storageStatus The storage status of the promise\n     * @dev Only the Chainlink oracle can call this function\n     */\n\n    function fulfillStorageStatusUpdate(\n        bytes32 _requestId,\n        address _promiseAddress,\n        uint8 _storageStatus\n    ) external recordChainlinkFulfillment(_requestId) {\n        s_promiseFactoryInterface.updateStorageStatus(\n            _promiseAddress,\n            _storageStatus\n        );\n\n        emit StorageStatusUpdateSuccessful(\n            _requestId,\n            _promiseAddress,\n            _storageStatus\n        );\n    }\n\n    /**\n     * @notice Set the address of the PromiseFactory contract\n     * @param _promiseFactoryContract: The address of the PromiseFactory contract\n     */\n\n    function setPromiseFactoryContract(address _promiseFactoryContract)\n        public\n        onlyOwner\n    {\n        s_promiseFactoryContract = _promiseFactoryContract;\n        s_promiseFactoryInterface = IPromiseFactory(_promiseFactoryContract);\n    }\n\n    // Getters\n\n    function getPromiseFactoryContract() public view returns (address) {\n        return s_promiseFactoryContract;\n    }\n\n    function getOraclePayment() public pure returns (uint256) {\n        return ORACLE_PAYMENT;\n    }\n}\n"
    },
    "contracts/tests/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\n"
    },
    "contracts/PromiseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\nimport \"./PromiseContract.sol\";\nimport \"./IVerifyStorage.sol\";\n\n/**\n * @author polarzero\n * @title PromiseFactory\n * @notice This is the factory contract initializing & referencing all promises\n * @dev This contract is the only one that can create new promises\n * For a successful flow, the following steps are recommended:\n * 1. Deploy the PromiseFactory contract\n * 2. Deploy the verifiers (VerifyStorage, VerifyTwitter)\n * 3. Set the verifiers in the PromiseFactory contract\n * 4. Fund the verifiers with LINK\n * 5. Deploy a new promise contract\n * * Only via the App can the promises be successfully verified by the VerifyStorage contract\n * * If you want to reproduce this verification, you will need your own External Adapter,\n * * and an interface that both encrypt/decrypt the IPFS & Arweave hashes with the same\n * * encryption key. More details in the documentation.\n */\n\ncontract PromiseFactory {\n    /// Errors\n    error PromiseFactory__EMPTY_FIELD();\n    error PromiseFactory__INCORRECT_FIELD_LENGTH();\n    error PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n    error PromiseFactory__addParticipant__NOT_PARTICIPANT();\n    error PromiseFactory__addParticipant__ALREADY_PARTICIPANT();\n    error PromiseFactory__NOT_OWNER();\n    error PromiseFactory__NOT_VERIFIER();\n\n    /// Variables\n    address private immutable i_owner;\n    // The VerifyTwitter contract\n    address private s_twitterVerifier;\n    // The VerifyStorage contract\n    address private s_storageVerifier;\n\n    // Map the owner addresses to the child contracts they created\n    mapping(address => PromiseContract[]) private s_promiseContracts;\n\n    // Map the user addresses to their verified Twitter account(s)\n    mapping(address => string[]) private s_twitterVerifiedUsers;\n\n    /// Events\n    // Emitted when a new PromiseContract is created\n    event PromiseContractCreated(\n        address indexed _owner,\n        address indexed _contractAddress,\n        string _promiseName,\n        string _ipfsCid,\n        string _arweaveId,\n        string encryptedProof,\n        string[] _partyNames,\n        string[] _partyTwitterHandles,\n        address[] _partyAddresses\n    );\n\n    // Emitted when a user was successfully verified by the VerifyTwitter contract\n    event TwitterAddVerifiedSuccessful(\n        address indexed _owner,\n        string _twitterHandle\n    );\n\n    // Emitted when a user was added to a PromiseContract\n    event ParticipantAdded(\n        address indexed _contractAddress,\n        string _participantName,\n        string _participantTwitterHandle,\n        address _participantAddress\n    );\n\n    // Emitted when a contract has just been created\n    // and a storage update request was sent to the VerifyStorage contract\n    event StorageStatusUpdateRequested(address promiseContract);\n\n    // Emitted when the storage status has been updated (to 1 - 3)\n    event StorageStatusUpdated(\n        address indexed _contractAddress,\n        uint8 _storageStatus\n    );\n\n    /// Modifiers\n    modifier onlyOwner() {\n        // msg sender should be the deployer of the contract\n        if (msg.sender != i_owner) {\n            revert PromiseFactory__NOT_OWNER();\n        }\n        _;\n    }\n\n    modifier onlyTwitterVerifier() {\n        if (msg.sender != s_twitterVerifier) {\n            revert PromiseFactory__NOT_VERIFIER();\n        }\n        _;\n    }\n\n    modifier onlyStorageVerifier() {\n        if (msg.sender != s_storageVerifier) {\n            revert PromiseFactory__NOT_VERIFIER();\n        }\n        _;\n    }\n\n    /// Functions\n\n    /**\n     * @notice Initialize the contract\n     */\n\n    constructor() {\n        i_owner = msg.sender;\n    }\n\n    /**\n     * @notice Create a new contract and add it to the list of child contracts\n     * @param _promiseName The name of the contract specified by the user\n     * @param _ipfsCid The CID of the directory stored on IPFS\n     * @param _arweaveId The ID of the zip stored on Arweave\n     * @param _encryptedProof The encrypted string of the promise name, user\n     * address, IPFS and Arweave hashes\n     * @param _partyNames The names of the parties specified by the user\n     * @param _partyTwitterHandles The Twitter handles of the parties specified by the user\n     * @param _partyAddresses The addresses specified by the user that will be allowed to interact\n     * with the contract\n     */\n\n    function createPromiseContract(\n        string memory _promiseName,\n        string memory _ipfsCid,\n        string memory _arweaveId,\n        string memory _encryptedProof,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) public returns (address promiseContractAddress) {\n        // Revert if one of the fields is empty\n        if (\n            !(bytes(_promiseName).length > 0 &&\n                bytes(_ipfsCid).length > 0 &&\n                _partyNames.length > 0 &&\n                _partyTwitterHandles.length > 0 &&\n                _partyAddresses.length > 0)\n        ) revert PromiseFactory__EMPTY_FIELD();\n\n        // Revert if the number of names, Twitter and addresses are not equal\n        // If Twitter handles are not provided, it will pass an empty string\n        if (\n            !(_partyAddresses.length == _partyTwitterHandles.length &&\n                _partyAddresses.length == _partyNames.length)\n        ) revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n\n        // Revert if the same address or twitter handle is used twice\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            for (uint256 j = i + 1; j < _partyAddresses.length; j++) {\n                if (\n                    _partyAddresses[i] == _partyAddresses[j] ||\n                    keccak256(abi.encodePacked(_partyTwitterHandles[i])) ==\n                    keccak256(abi.encodePacked(_partyTwitterHandles[j]))\n                )\n                    revert PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n            }\n        }\n\n        // We could test the validity of the Twitter handles here, but it would not really matter\n        // since it won't have any value without being verified, and the verification already\n        // needs it to be valid\n\n        // Revert if the name of the promise is longer than 70 characters\n        if (bytes(_promiseName).length > 70) {\n            revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n        }\n\n        // We don't need to check the length of the Twitter handles\n        // If any were to be invalid, they would fail to get verified\n\n        // We can't make sure the provided CID is valid,\n        // because it could be provided either in a Base58 or Base32 format\n        // but it will be shown in the UI\n\n        // Create a new contract for this promise\n        PromiseContract promiseContract = new PromiseContract(\n            msg.sender,\n            _promiseName,\n            _ipfsCid,\n            _arweaveId,\n            _encryptedProof,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n        s_promiseContracts[msg.sender].push(promiseContract);\n\n        emit PromiseContractCreated(\n            msg.sender,\n            address(promiseContract),\n            _promiseName,\n            _ipfsCid,\n            _arweaveId,\n            _encryptedProof,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n\n        // Request a storage status update to the VerifyStorage contract\n        IVerifyStorage(s_storageVerifier).requestStorageStatusUpdate(\n            address(promiseContract),\n            msg.sender,\n            _ipfsCid,\n            _arweaveId,\n            _encryptedProof\n        );\n        emit StorageStatusUpdateRequested(address(promiseContract));\n\n        return address(promiseContract);\n    }\n\n    /**\n     * @notice Add a participant to a promise contract\n     * @dev Only a participant of the contract can call this function\n     * @dev It can only be called if the contract is not locked (the child contract takes care of that)\n     * @param _promiseContractAddress The address of the promise contract\n     * @param _partyName The name of the party\n     * @param _partyTwitterHandle The Twitter handle of the party\n     * @param _partyAddress The address of the party\n     */\n\n    function addParticipant(\n        address _promiseContractAddress,\n        string memory _partyName,\n        string memory _partyTwitterHandle,\n        address _partyAddress\n    ) public {\n        // Revert if the sender is not a participant of the contract\n        if (\n            !PromiseContract(_promiseContractAddress).getIsParticipant(\n                msg.sender\n            )\n        ) {\n            revert PromiseFactory__addParticipant__NOT_PARTICIPANT();\n        }\n\n        // Revert if the user to add is already a participant of the contract\n        if (\n            PromiseContract(_promiseContractAddress).getIsParticipant(\n                _partyAddress\n            )\n        ) {\n            revert PromiseFactory__addParticipant__ALREADY_PARTICIPANT();\n        }\n\n        // Revert if the name of the party is longer than 30 characters\n        if (bytes(_partyName).length > 30) {\n            revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n        }\n\n        // Add the participant to the contract and emit an event\n        PromiseContract(_promiseContractAddress).createParticipant(\n            _partyName,\n            _partyTwitterHandle,\n            _partyAddress,\n            true // Reset the approval status\n        );\n\n        emit ParticipantAdded(\n            _promiseContractAddress,\n            _partyName,\n            _partyTwitterHandle,\n            _partyAddress\n        );\n    }\n\n    /**\n     * @notice Add a verified Twitter account to the list of verified accounts\n     * @dev Only the verifier contract can call this function, after the account\n     * has been verified with the Chainlink Node + External Adapter\n     * @param _userAddress The address of the user\n     * @param _twitterHandle The Twitter handle of the verified account\n     */\n\n    function addTwitterVerifiedUser(\n        address _userAddress,\n        string memory _twitterHandle\n    ) external onlyTwitterVerifier {\n        // If the user address doesn't have a verified account yet, create a new array\n        if (s_twitterVerifiedUsers[_userAddress].length == 0) {\n            s_twitterVerifiedUsers[_userAddress] = new string[](1);\n            // Add the verified account to the array\n            s_twitterVerifiedUsers[_userAddress][0] = _twitterHandle;\n        } else if (s_twitterVerifiedUsers[_userAddress].length > 0) {\n            string[] memory verifiedAccounts = s_twitterVerifiedUsers[\n                _userAddress\n            ];\n            for (uint256 i = 0; i < verifiedAccounts.length; i++) {\n                // If the user already verified this account, revert\n                if (\n                    keccak256(abi.encodePacked(verifiedAccounts[i])) ==\n                    keccak256(abi.encodePacked(_twitterHandle))\n                ) {\n                    emit TwitterAddVerifiedSuccessful(\n                        _userAddress,\n                        _twitterHandle\n                    );\n                    return;\n                }\n            }\n            // But if it is not included, add it\n            s_twitterVerifiedUsers[_userAddress].push(_twitterHandle);\n        }\n\n        emit TwitterAddVerifiedSuccessful(_userAddress, _twitterHandle);\n    }\n\n    /**\n     * @notice Update the storage status of a promise contract\n     * @dev Only the verifier contract can call this function, after the storage\n     * has been verified with the Chainlink Node + External Adapter\n     * @dev This step could as well be avoided for better optimization, since\n     * VerifyStorage could directly call the PromiseContract to update its status\n     * BUT we want to do it this way, because:\n     * - it helps us keep this PromiseFactory contract as a mediator, which\n     * allows for better event tracking & easier security measures\n     * - it is not a major flaw in terms of gas usage, as long as we're deploying\n     * on a L2 solution\n     * @param _promiseContractAddress The address of the promise contract\n     * @param _storageStatus The new storage status\n     * -> 1 = failed, 2 = IPFS provided & verified, 3 = IPFS + Arweave provided & verified\n     */\n\n    function updateStorageStatus(\n        address _promiseContractAddress,\n        uint8 _storageStatus\n    ) external onlyStorageVerifier {\n        PromiseContract(_promiseContractAddress).updateStorageStatus(\n            _storageStatus\n        );\n        emit StorageStatusUpdated(_promiseContractAddress, _storageStatus);\n    }\n\n    /// Setters\n    function setTwitterVerifier(address _twitterVerifier) external onlyOwner {\n        s_twitterVerifier = _twitterVerifier;\n    }\n\n    function setStorageVerifier(address _storageVerifier) external onlyOwner {\n        s_storageVerifier = _storageVerifier;\n    }\n\n    /// Getters\n    function getPromiseContractAddresses(address _owner)\n        public\n        view\n        returns (PromiseContract[] memory)\n    {\n        return s_promiseContracts[_owner];\n    }\n\n    function getPromiseContractCount(address _userAddress)\n        public\n        view\n        returns (uint256)\n    {\n        return s_promiseContracts[_userAddress].length;\n    }\n\n    function getTwitterVerifiedHandle(address _userAddress)\n        public\n        view\n        returns (string[] memory)\n    {\n        // Return the username if the user has a verified account\n        if (s_twitterVerifiedUsers[_userAddress].length > 0) {\n            return s_twitterVerifiedUsers[_userAddress];\n        } else {\n            // Return an empty array\n            string[] memory usernames = new string[](0);\n            return usernames;\n        }\n    }\n\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getTwitterVerifier() public view returns (address) {\n        return s_twitterVerifier;\n    }\n\n    function getStorageVerifier() public view returns (address) {\n        return s_storageVerifier;\n    }\n}\n"
    },
    "contracts/PromiseContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @author polarzero\n * @title Promise Contract\n * @notice This is the child contract generated by the Promise Factory\n * once a user creates a new promise\n */\n\ncontract PromiseContract {\n    /// Errors\n    error PromiseContract__NOT_FACTORY();\n    error PromiseContract__NOT_PARTICIPANT();\n    error PromiseContract__PROMISE_LOCKED();\n    error PromiseContract__createParticipant__INCORRECT_FIELD_LENGTH();\n    error PromiseContract__approvePromise__ALREADY_APPROVED();\n    error PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();\n    error PromiseContract__updateStorageStatus__INVALID_STATUS();\n\n    /// Types\n    struct Participant {\n        string participantName;\n        string participantTwitterHandle;\n        address participantAddress;\n    }\n\n    /// Variables\n    uint256 private s_participantCount = 0;\n    // If the promise is created through the website, the content uploaded to IPFS\n    // and eventually Arweave can be verified with the encryptedProof\n    // which will result in a storageStatus that provides information on the persistence of the data\n    // storageStatus = 0 -> the provided IPFS and Arweave hashes have not yet been verified\n    // storageStatus = 1 -> the provided IPFS and eventually Arweave hashes could not be verified\n    // storageStatus = 2 -> only the IPFS hash has been provided and verified\n    // storageStatus = 3 -> both the IPFS & Arweave hashes has been provided and verified\n    uint8 private s_storageStatus = 0;\n    // The 3 following variables need to be stored in a string because of their length\n    // So they cannot be set to immutable\n    string private s_promiseName;\n    string private s_ipfsCid;\n    string private s_arweaveId;\n    string private s_encryptedProof;\n    address private immutable i_owner;\n    address private immutable i_promiseFactoryContract;\n    address[] private s_participantAddresses;\n    bool private s_promiseLocked = false;\n\n    // Mapping of addresses to name & twitter handle\n    mapping(address => Participant) private s_parties;\n    // Mapping of addresses to whether or not they have approved the agreement\n    mapping(address => bool) private s_approvedParties;\n\n    /// Events\n    event ParticipantCreated(\n        string participantName,\n        string participantTwitterHandle,\n        address indexed participantAddress\n    );\n\n    event ParticipantApproved(\n        string participantName,\n        string participantTwitterHandle,\n        address indexed participantAddress\n    );\n\n    event PromiseLocked();\n\n    event PromiseStorageStatusUpdated(uint8 storageStatus);\n\n    /// Modifiers\n    modifier onlyParticipant() {\n        bool isParticipant = getIsParticipant(msg.sender);\n\n        if (!isParticipant) revert PromiseContract__NOT_PARTICIPANT();\n        _;\n    }\n\n    modifier onlyUnlocked() {\n        if (s_promiseLocked) revert PromiseContract__PROMISE_LOCKED();\n        _;\n    }\n\n    modifier onlyPromiseFactory() {\n        if (msg.sender != i_promiseFactoryContract)\n            revert PromiseContract__NOT_FACTORY();\n        _;\n    }\n\n    /// Functions\n    /**\n     * @dev Initialize the contract from the Master Contract with the user address as the owner\n     * @param _owner The address of the creator of the promise\n     * @param _promiseName The name of the promise\n     * @param _ipfsCid The IPFS CID of the content\n     * @param _arweaveId The Arweave ID of the content\n     * @param _encryptedProof The encrypted proof of the promise (see ./VerifyStorage.sol)\n     * @param _partyNames The names of the parties\n     * @param _partyTwitterHandles The twitter handles of the parties (optional, if not provided = '')\n     * @param _partyAddresses The addresses of the parties\n     */\n\n    constructor(\n        address _owner,\n        string memory _promiseName,\n        string memory _ipfsCid,\n        string memory _arweaveId,\n        string memory _encryptedProof,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) {\n        i_promiseFactoryContract = msg.sender;\n        i_owner = _owner;\n        s_promiseName = _promiseName;\n        s_ipfsCid = _ipfsCid;\n        s_arweaveId = _arweaveId;\n        s_encryptedProof = _encryptedProof;\n\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            createParticipant(\n                _partyNames[i],\n                _partyTwitterHandles[i],\n                _partyAddresses[i],\n                false // The promise is being initialized, no need to reset approval status\n            );\n        }\n    }\n\n    /**\n     * @notice Approve the promise as a participant\n     */\n\n    function approvePromise() public onlyParticipant onlyUnlocked {\n        if (s_approvedParties[msg.sender] == true) {\n            revert PromiseContract__approvePromise__ALREADY_APPROVED();\n        }\n\n        s_approvedParties[msg.sender] = true;\n        emit ParticipantApproved(\n            s_parties[msg.sender].participantName,\n            s_parties[msg.sender].participantTwitterHandle,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Validate the promise and lock it so that no more participants can change any state\n     * or even try to and lose gas\n     */\n\n    function lockPromise() public onlyParticipant onlyUnlocked {\n        address[] memory participantAddresses = s_participantAddresses;\n\n        // Loop through the parties and check if anyone has not approved yet\n        for (uint256 i = 0; i < s_participantCount; i++) {\n            if (s_approvedParties[participantAddresses[i]] == false) {\n                revert PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();\n            }\n        }\n\n        s_promiseLocked = true;\n        emit PromiseLocked();\n    }\n\n    /**\n     * @notice Create a new participant and add them to the mapping\n     * @dev This function can only be called by the Promise Factory\n     * @param _participantName The name of the participant\n     * @param _participantTwitterHandle The twitter handle of the participant\n     * @param _participantAddress The address of the participant\n     * @param _resetApprovalStatus Whether or not to reset the approval status of the participants\n     * -> true if a participant is being added after the promise creation\n     */\n\n    function createParticipant(\n        string memory _participantName,\n        string memory _participantTwitterHandle,\n        address _participantAddress,\n        bool _resetApprovalStatus\n    ) public onlyPromiseFactory onlyUnlocked {\n        // Revert if the name is not between 2 and 30 characters\n        if (\n            bytes(_participantName).length < 2 ||\n            bytes(_participantName).length > 30\n        ) {\n            revert PromiseContract__createParticipant__INCORRECT_FIELD_LENGTH();\n        }\n        Participant memory participant = Participant(\n            _participantName,\n            _participantTwitterHandle,\n            _participantAddress\n        );\n        s_parties[_participantAddress] = participant;\n        s_participantAddresses.push(_participantAddress);\n        s_participantCount++;\n\n        // Make sure the promise gets disapproved for every participants\n        // In case a new participant is added, they will need to approve it again\n        // We just need to do this if a participant is being added, not at the initialization\n        if (_resetApprovalStatus) {\n            address[] memory participantAddresses = s_participantAddresses;\n\n            for (uint256 i = 0; i < s_participantCount; i++) {\n                // Set the approval to false if it's been approved already\n                if (s_approvedParties[participantAddresses[i]] == true) {\n                    s_approvedParties[participantAddresses[i]] = false;\n                }\n            }\n        }\n\n        emit ParticipantCreated(\n            _participantName,\n            _participantTwitterHandle,\n            _participantAddress\n        );\n    }\n\n    /**\n     * @notice Update the storage status of the promise\n     * @dev This function can only be called by the Promise Factory\n     * @param _storageStatus The new storage status of the promise\n     * - 1 -> the provided IPFS and eventually Arweave hashes could not be verified\n     * - 2 -> only the IPFS hash has been provided and verified\n     * - 3 -> both the IPFS & Arweave hashes has been provided and verified\n     */\n\n    function updateStorageStatus(uint8 _storageStatus)\n        public\n        onlyPromiseFactory\n    {\n        if (_storageStatus < 1 || _storageStatus > 3) {\n            revert PromiseContract__updateStorageStatus__INVALID_STATUS();\n        }\n\n        s_storageStatus = _storageStatus;\n        emit PromiseStorageStatusUpdated(_storageStatus);\n    }\n\n    /// Getters\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getName() public view returns (string memory) {\n        return s_promiseName;\n    }\n\n    function getIpfsCid() public view returns (string memory) {\n        return s_ipfsCid;\n    }\n\n    function getArweaveId() public view returns (string memory) {\n        return s_arweaveId;\n    }\n\n    function getEncryptedProof() public view returns (string memory) {\n        return s_encryptedProof;\n    }\n\n    function getStorageStatus() public view returns (uint8) {\n        return s_storageStatus;\n    }\n\n    function getParticipant(address _address)\n        public\n        view\n        returns (Participant memory)\n    {\n        return s_parties[_address];\n    }\n\n    function getIsParticipant(address _participantAddress)\n        public\n        view\n        returns (bool)\n    {\n        if (s_parties[_participantAddress].participantAddress == address(0)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function getParticipantCount() public view returns (uint256) {\n        return s_participantCount;\n    }\n\n    function getIsPromiseApproved(address _participantAddress)\n        public\n        view\n        returns (bool)\n    {\n        return s_approvedParties[_participantAddress];\n    }\n\n    function getIsPromiseLocked() public view returns (bool) {\n        return s_promiseLocked;\n    }\n\n    function getPromiseFactoryContract() public view returns (address) {\n        return i_promiseFactoryContract;\n    }\n}\n"
    },
    "contracts/IVerifyStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IVerifyStorage {\n    function requestStorageStatusUpdate(\n        address _promiseContractAddress,\n        address _userAddress,\n        string memory _ipfsHash,\n        string memory _arweaveId,\n        string memory _encryptedProof\n    ) external;\n}\n"
    },
    "contracts/MockPromiseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\nimport \"./PromiseContract.sol\";\nimport \"./IVerifyStorage.sol\";\n\n/**\n * @author polarzero\n * @title MockPromiseFactory\n * @notice This is the factory contract initializing & referencing all promises\n * @dev This contract is the only one that can create new promises\n * For a successful flow, the following steps are recommended:\n * 1. Deploy the PromiseFactory contract\n * 2. Deploy the verifiers (VerifyStorage, VerifyTwitter)\n * 3. Set the verifiers in the PromiseFactory contract\n * 4. Fund the verifiers with LINK\n * 5. Deploy a new promise contract\n * * Only via the App can the promises be successfully verified by the VerifyStorage contract\n * * If you want to reproduce this verification, you will need your own External Adapter,\n * * and an interface that both encrypt/decrypt the IPFS & Arweave hashes with the same\n * * encryption key. More details in the documentation.\n * @dev This contract is identical to the PromiseFactory contract, except that it\n * doesn't actually make a request to the VerifyStorage contract on a promise creation\n */\n\ncontract MockPromiseFactory {\n    /// Errors\n    error PromiseFactory__EMPTY_FIELD();\n    error PromiseFactory__INCORRECT_FIELD_LENGTH();\n    error PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n    error PromiseFactory__addParticipant__NOT_PARTICIPANT();\n    error PromiseFactory__addParticipant__ALREADY_PARTICIPANT();\n    error PromiseFactory__NOT_OWNER();\n    error PromiseFactory__NOT_VERIFIER();\n\n    /// Variables\n    address private immutable i_owner;\n    // The VerifyTwitter contract\n    address private s_twitterVerifier;\n    // The VerifyStorage contract\n    address private s_storageVerifier;\n\n    // Map the owner addresses to the child contracts they created\n    mapping(address => PromiseContract[]) private s_promiseContracts;\n\n    // Map the user addresses to their verified Twitter account(s)\n    mapping(address => string[]) private s_twitterVerifiedUsers;\n\n    /// Events\n    // Emitted when a new PromiseContract is created\n    event PromiseContractCreated(\n        address indexed _owner,\n        address indexed _contractAddress,\n        string _promiseName,\n        string _ipfsCid,\n        string _arweaveId,\n        string encryptedProof,\n        string[] _partyNames,\n        string[] _partyTwitterHandles,\n        address[] _partyAddresses\n    );\n\n    // Emitted when a user was successfully verified by the VerifyTwitter contract\n    event TwitterAddVerifiedSuccessful(\n        address indexed _owner,\n        string _twitterHandle\n    );\n\n    // Emitted when a user was added to a PromiseContract\n    event ParticipantAdded(\n        address indexed _contractAddress,\n        string _participantName,\n        string _participantTwitterHandle,\n        address _participantAddress\n    );\n\n    // Emitted when a contract has just been created\n    // and a storage update request was sent to the VerifyStorage contract\n    event StorageStatusUpdateRequested(address promiseContract);\n\n    // Emitted when the storage status has been updated (to 1 - 3)\n    event StorageStatusUpdated(\n        address indexed _contractAddress,\n        uint8 _storageStatus\n    );\n\n    /// Modifiers\n    modifier onlyOwner() {\n        // msg sender should be the deployer of the contract\n        if (msg.sender != i_owner) {\n            revert PromiseFactory__NOT_OWNER();\n        }\n        _;\n    }\n\n    modifier onlyTwitterVerifier() {\n        if (msg.sender != s_twitterVerifier) {\n            revert PromiseFactory__NOT_VERIFIER();\n        }\n        _;\n    }\n\n    modifier onlyStorageVerifier() {\n        if (msg.sender != s_storageVerifier) {\n            revert PromiseFactory__NOT_VERIFIER();\n        }\n        _;\n    }\n\n    /// Functions\n\n    /**\n     * @notice Initialize the contract\n     */\n\n    constructor() {\n        i_owner = msg.sender;\n    }\n\n    /**\n     * @notice Create a new contract and add it to the list of child contracts\n     * @param _promiseName The name of the contract specified by the user\n     * @param _ipfsCid The CID of the directory stored on IPFS\n     * @param _arweaveId The ID of the zip stored on Arweave\n     * @param _encryptedProof The encrypted string of the promise name, user\n     * address, IPFS and Arweave hashes\n     * @param _partyNames The names of the parties specified by the user\n     * @param _partyTwitterHandles The Twitter handles of the parties specified by the user\n     * @param _partyAddresses The addresses specified by the user that will be allowed to interact\n     * with the contract\n     */\n\n    function createPromiseContract(\n        string memory _promiseName,\n        string memory _ipfsCid,\n        string memory _arweaveId,\n        string memory _encryptedProof,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) public returns (address promiseContractAddress) {\n        // Revert if one of the fields is empty\n        if (\n            !(bytes(_promiseName).length > 0 &&\n                bytes(_ipfsCid).length > 0 &&\n                _partyNames.length > 0 &&\n                _partyTwitterHandles.length > 0 &&\n                _partyAddresses.length > 0)\n        ) revert PromiseFactory__EMPTY_FIELD();\n\n        // Revert if the number of names, Twitter and addresses are not equal\n        // If Twitter handles are not provided, it will pass an empty string\n        if (\n            !(_partyAddresses.length == _partyTwitterHandles.length &&\n                _partyAddresses.length == _partyNames.length)\n        ) revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n\n        // Revert if the same address or twitter handle is used twice\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            for (uint256 j = i + 1; j < _partyAddresses.length; j++) {\n                if (\n                    _partyAddresses[i] == _partyAddresses[j] ||\n                    keccak256(abi.encodePacked(_partyTwitterHandles[i])) ==\n                    keccak256(abi.encodePacked(_partyTwitterHandles[j]))\n                )\n                    revert PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n            }\n        }\n\n        // We could test the validity of the Twitter handles here, but it would not really matter\n        // since it won't have any value without being verified, and the verification already\n        // needs it to be valid\n\n        // Revert if the name of the promise is longer than 70 characters\n        if (bytes(_promiseName).length > 70) {\n            revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n        }\n\n        // We don't need to check the length of the Twitter handles\n        // If any were to be invalid, they would fail to get verified\n\n        // We can't make sure the provided CID is valid,\n        // because it could be provided either in a Base58 or Base32 format\n        // but it will be shown in the UI\n\n        // Create a new contract for this promise\n        PromiseContract promiseContract = new PromiseContract(\n            msg.sender,\n            _promiseName,\n            _ipfsCid,\n            _arweaveId,\n            _encryptedProof,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n        s_promiseContracts[msg.sender].push(promiseContract);\n\n        emit PromiseContractCreated(\n            msg.sender,\n            address(promiseContract),\n            _promiseName,\n            _ipfsCid,\n            _arweaveId,\n            _encryptedProof,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n\n        // Pretend that a storage status update is requested\n        // to the VerifyStorage contract\n        // ! Here is the only difference with PromiseFactory.sol\n        emit StorageStatusUpdateRequested(address(promiseContract));\n\n        return address(promiseContract);\n    }\n\n    /**\n     * @notice Add a participant to a promise contract\n     * @dev Only a participant of the contract can call this function\n     * @dev It can only be called if the contract is not locked (the child contract takes care of that)\n     * @param _promiseContractAddress The address of the promise contract\n     * @param _partyName The name of the party\n     * @param _partyTwitterHandle The Twitter handle of the party\n     * @param _partyAddress The address of the party\n     */\n\n    function addParticipant(\n        address _promiseContractAddress,\n        string memory _partyName,\n        string memory _partyTwitterHandle,\n        address _partyAddress\n    ) public {\n        // Revert if the sender is not a participant of the contract\n        if (\n            !PromiseContract(_promiseContractAddress).getIsParticipant(\n                msg.sender\n            )\n        ) {\n            revert PromiseFactory__addParticipant__NOT_PARTICIPANT();\n        }\n\n        // Revert if the user to add is already a participant of the contract\n        if (\n            PromiseContract(_promiseContractAddress).getIsParticipant(\n                _partyAddress\n            )\n        ) {\n            revert PromiseFactory__addParticipant__ALREADY_PARTICIPANT();\n        }\n\n        // Revert if the name of the party is longer than 30 characters\n        if (bytes(_partyName).length > 30) {\n            revert PromiseFactory__INCORRECT_FIELD_LENGTH();\n        }\n\n        // Add the participant to the contract and emit an event if successful\n        PromiseContract(_promiseContractAddress).createParticipant(\n            _partyName,\n            _partyTwitterHandle,\n            _partyAddress,\n            true // Reset the approval status\n        );\n\n        emit ParticipantAdded(\n            _promiseContractAddress,\n            _partyName,\n            _partyTwitterHandle,\n            _partyAddress\n        );\n    }\n\n    /**\n     * @notice Add a verified Twitter account to the list of verified accounts\n     * @dev Only the verifier contract can call this function, after the account\n     * has been verified with the Chainlink Node + External Adapter\n     * @param _userAddress The address of the user\n     * @param _twitterHandle The Twitter handle of the verified account\n     */\n\n    function addTwitterVerifiedUser(\n        address _userAddress,\n        string memory _twitterHandle\n    ) external onlyTwitterVerifier {\n        // If the user address doesn't have a verified account yet, create a new array\n        if (s_twitterVerifiedUsers[_userAddress].length == 0) {\n            s_twitterVerifiedUsers[_userAddress] = new string[](1);\n            // Add the verified account to the array\n            s_twitterVerifiedUsers[_userAddress][0] = _twitterHandle;\n        } else if (s_twitterVerifiedUsers[_userAddress].length > 0) {\n            string[] memory verifiedAccounts = s_twitterVerifiedUsers[\n                _userAddress\n            ];\n            for (uint256 i = 0; i < verifiedAccounts.length; i++) {\n                // If the user already verified this account, revert\n                if (\n                    keccak256(abi.encodePacked(verifiedAccounts[i])) ==\n                    keccak256(abi.encodePacked(_twitterHandle))\n                ) {\n                    emit TwitterAddVerifiedSuccessful(\n                        _userAddress,\n                        _twitterHandle\n                    );\n                    return;\n                }\n            }\n            // But if it is not included, add it\n            s_twitterVerifiedUsers[_userAddress].push(_twitterHandle);\n        }\n\n        emit TwitterAddVerifiedSuccessful(_userAddress, _twitterHandle);\n    }\n\n    /**\n     * @notice Update the storage status of a promise contract\n     * @dev Only the verifier contract can call this function, after the storage\n     * has been verified with the Chainlink Node + External Adapter\n     * @dev This step could as well be avoided for better optimization, since\n     * VerifyStorage could directly call the PromiseContract to update its status\n     * BUT we want to do it this way, because:\n     * - it helps us keep this PromiseFactory contract as a mediator, which\n     * allows for better event tracking & easier security measures\n     * - it is not a major flaw in terms of gas usage, as long as we're deploying\n     * on a L2 solution\n     * @param _promiseContractAddress The address of the promise contract\n     * @param _storageStatus The new storage status\n     * -> 1 = failed, 2 = IPFS provided & verified, 3 = IPFS + Arweave provided & verified\n     */\n\n    function updateStorageStatus(\n        address _promiseContractAddress,\n        uint8 _storageStatus\n    ) external onlyStorageVerifier {\n        PromiseContract(_promiseContractAddress).updateStorageStatus(\n            _storageStatus\n        );\n        emit StorageStatusUpdated(_promiseContractAddress, _storageStatus);\n    }\n\n    /// Setters\n    function setTwitterVerifier(address _twitterVerifier) external onlyOwner {\n        s_twitterVerifier = _twitterVerifier;\n    }\n\n    function setStorageVerifier(address _storageVerifier) external onlyOwner {\n        s_storageVerifier = _storageVerifier;\n    }\n\n    /// Getters\n    function getPromiseContractAddresses(address _owner)\n        public\n        view\n        returns (PromiseContract[] memory)\n    {\n        return s_promiseContracts[_owner];\n    }\n\n    function getPromiseContractCount(address _userAddress)\n        public\n        view\n        returns (uint256)\n    {\n        return s_promiseContracts[_userAddress].length;\n    }\n\n    function getTwitterVerifiedHandle(address _userAddress)\n        public\n        view\n        returns (string[] memory)\n    {\n        // Return the username if the user has a verified account\n        if (s_twitterVerifiedUsers[_userAddress].length > 0) {\n            return s_twitterVerifiedUsers[_userAddress];\n        } else {\n            // Return an empty array\n            string[] memory usernames = new string[](0);\n            return usernames;\n        }\n    }\n\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}