{
  "language": "Solidity",
  "sources": {
    "contracts/PromiseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./PromiseContract.sol\";\n\n/**\n * @author polarzero\n * @title Master Contract\n * @notice This is the master contract initializing & referencing all child contracts\n */\n\ncontract PromiseFactory {\n    /// Errors\n    error PromiseFactory__createPromiseContract__EMPTY_FIELD();\n    error PromiseFactory__createPromiseContract__INCORRECT_FIELD_LENGTH();\n    error PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n    error PromiseFactory__createPromiseContract__INVALID_URI();\n    // error PromiseFactory__addTwitterVerifiedUser__ALREADY_VERIFIED();\n    error PromiseFactory__NOT_OWNER();\n    error PromiseFactory__NOT_VERIFIER();\n\n    /// Variables\n    address private immutable i_owner;\n    // The VerifyTwitter contract\n    address private s_verifier;\n\n    // Map the owner addresses to the child contracts they created\n    mapping(address => PromiseContract[]) private s_promiseContracts;\n\n    // Map the user addresses to their verified Twitter account(s)\n    mapping(address => string[]) private s_twitterVerifiedUsers;\n\n    /// Events\n    event PromiseContractCreated(\n        address indexed _owner,\n        address indexed _contractAddress,\n        string _promiseName,\n        string _pdfUri,\n        string[] _partyNames,\n        string[] _partyTwitterHandles,\n        address[] _partyAddresses\n    );\n\n    event TwitterAddVerifiedSuccessful(\n        address indexed _owner,\n        string _twitterHandle\n    );\n\n    event TwitterAddVerifiedFailed(\n        address indexed _owner,\n        string _twitterHandle\n    );\n\n    /// Modifiers\n    modifier onlyOwner() {\n        // msg sender should be the deployer of the contract\n        if (msg.sender != i_owner) {\n            revert PromiseFactory__NOT_OWNER();\n        }\n        _;\n    }\n\n    modifier onlyVerifier() {\n        if (msg.sender != s_verifier) {\n            revert PromiseFactory__NOT_VERIFIER();\n        }\n        _;\n    }\n\n    /// Functions\n\n    /**\n     * @notice Initialize the contract\n     */\n\n    constructor(address _verifier) {\n        i_owner = msg.sender;\n        s_verifier = _verifier;\n    }\n\n    /**\n     * @notice Create a new contract and add it to the list of child contracts\n     * @param _promiseName The name of the contract specified by the user\n     * @param _pdfUri The URI of the PDF file stored on IPFS\n     * @param _partyNames The names of the parties specified by the user\n     * @param _partyTwitterHandles The Twitter handles of the parties specified by the user\n     * @param _partyAddresses The addresses specified by the user that will be allowed to interact\n     * with the contract\n     */\n\n    function createPromiseContract(\n        string memory _promiseName,\n        string memory _pdfUri,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) public returns (address promiseContractAddress) {\n        // Revert if one of the fields is empty\n        if (\n            !(bytes(_promiseName).length > 0 &&\n                bytes(_pdfUri).length > 0 &&\n                _partyNames.length > 0 &&\n                _partyAddresses.length > 0)\n        ) revert PromiseFactory__createPromiseContract__EMPTY_FIELD();\n\n        // Revert if the number of names, Twitter and addresses are not equal\n        // If Twitter handles are not provided, it will pass an empty string\n        if (\n            !(_partyAddresses.length == _partyTwitterHandles.length &&\n                _partyAddresses.length == _partyNames.length)\n        )\n            revert PromiseFactory__createPromiseContract__INCORRECT_FIELD_LENGTH();\n\n        // Revert if the same address or twitter handle is used twice\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            for (uint256 j = i + 1; j < _partyAddresses.length; j++) {\n                if (\n                    _partyAddresses[i] == _partyAddresses[j] ||\n                    keccak256(abi.encodePacked(_partyTwitterHandles[i])) ==\n                    keccak256(abi.encodePacked(_partyTwitterHandles[j]))\n                )\n                    revert PromiseFactory__createPromiseContract__DUPLICATE_FIELD();\n            }\n        }\n\n        // We could test the validity of the Twitter handles here, but it would not really matter\n        // since it won't have any value without being verified, and the verification already\n        // needs it to be valid\n\n        // Revert if the name of the promise is longer than 70 characters\n        if (bytes(_promiseName).length > 70) {\n            revert PromiseFactory__createPromiseContract__INCORRECT_FIELD_LENGTH();\n        }\n\n        // Check if the provided URI is a valid IPFS URI\n        bytes memory pdfUriBytes = bytes(_pdfUri);\n\n        // Minimum 5 bytes encoded in Base58 -> minimum 7 characters\n        if (!(pdfUriBytes.length > 6))\n            revert PromiseFactory__createPromiseContract__INVALID_URI();\n\n        // It should match the allowed characters in Base58\n        for (uint i = 0; i < pdfUriBytes.length; i++) {\n            if (\n                !(0x7ffeffe07ff7dfe03fe000000000000 &\n                    (uint(1) << uint8(pdfUriBytes[i])) >\n                    0)\n            ) {\n                revert PromiseFactory__createPromiseContract__INVALID_URI();\n            }\n        }\n\n        // Create a new contract for this promise\n        PromiseContract promiseContract = new PromiseContract(\n            msg.sender,\n            _promiseName,\n            _pdfUri,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n        s_promiseContracts[msg.sender].push(promiseContract);\n\n        emit PromiseContractCreated(\n            msg.sender,\n            address(promiseContract),\n            _promiseName,\n            _pdfUri,\n            _partyNames,\n            _partyTwitterHandles,\n            _partyAddresses\n        );\n\n        return address(promiseContract);\n    }\n\n    /**\n     * @notice Add a verified Twitter account to the list of verified accounts\n     * @dev Only the verifier contract can call this function, after the account\n     * has been verified with the Chainlink Node + External Adapter\n     * @param _userAddress The address of the user\n     * @param _twitterHandle The Twitter handle of the verified account\n     */\n\n    function addTwitterVerifiedUser(\n        address _userAddress,\n        string memory _twitterHandle\n    ) external onlyVerifier {\n        // If the user address doesn't have a verified account yet, create a new array\n        if (s_twitterVerifiedUsers[_userAddress].length == 0) {\n            s_twitterVerifiedUsers[_userAddress] = new string[](1);\n            // Add the verified account to the array\n            s_twitterVerifiedUsers[_userAddress][0] = _twitterHandle;\n        } else if (s_twitterVerifiedUsers[_userAddress].length > 0) {\n            string[] memory verifiedAccounts = s_twitterVerifiedUsers[\n                _userAddress\n            ];\n            for (uint256 i = 0; i < verifiedAccounts.length; i++) {\n                // If the user already verified this account, revert\n                if (\n                    keccak256(abi.encodePacked(verifiedAccounts[i])) ==\n                    keccak256(abi.encodePacked(_twitterHandle))\n                ) {\n                    emit TwitterAddVerifiedFailed(_userAddress, _twitterHandle);\n                    return;\n                }\n            }\n            // But if it is not included, add it\n            s_twitterVerifiedUsers[_userAddress].push(_twitterHandle);\n            emit TwitterAddVerifiedSuccessful(_userAddress, _twitterHandle);\n        }\n    }\n\n    /// Setters\n    function setVerifier(address _verifier) external onlyOwner {\n        s_verifier = _verifier;\n    }\n\n    /// Getters\n    function getPromiseContractAddresses(address _owner)\n        public\n        view\n        returns (PromiseContract[] memory)\n    {\n        return s_promiseContracts[_owner];\n    }\n\n    function getPromiseContractCount(address _userAddress)\n        public\n        view\n        returns (uint256)\n    {\n        return s_promiseContracts[_userAddress].length;\n    }\n\n    function getTwitterVerifiedHandle(address _userAddress)\n        public\n        view\n        returns (string[] memory)\n    {\n        // Return the username if the user has a verified account\n        if (s_twitterVerifiedUsers[_userAddress].length > 0) {\n            return s_twitterVerifiedUsers[_userAddress];\n        } else {\n            // Return an empty array\n            string[] memory usernames = new string[](0);\n            return usernames;\n        }\n    }\n\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getVerifier() public view returns (address) {\n        return s_verifier;\n    }\n}\n"
    },
    "contracts/PromiseContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @author polarzero\n * @title Promise Contract\n * @notice This is the child contract generated by the Promise Factory\n * once a user creates a new promise\n */\n\ncontract PromiseContract {\n    /// Errors\n    error PromiseContract__NOT_PARTICIPANT();\n    error PromiseContract__PROMISE_LOCKED();\n    error PromiseContract__approvePromise__ALREADY_APPROVED();\n    error PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();\n\n    /// Types\n    struct Participant {\n        string participantName;\n        string participantTwitterHandle;\n        address participantAddress;\n    }\n\n    /// Variables\n    uint256 public s_participantCount;\n    string public s_promiseName;\n    string public s_pdfUri;\n    address public immutable i_owner;\n    address[] public s_participantAddresses;\n    bool public s_promiseLocked = false;\n\n    // Mapping of addresses to name & twitter handle\n    mapping(address => Participant) public s_parties;\n    // Mapping of addresses to whether or not they have approved the agreement\n    mapping(address => bool) public s_approvedParties;\n\n    /// Events\n    event ParticipantCreated(\n        string participantName,\n        string participantTwitterHandle,\n        address indexed participantAddress\n    );\n\n    event ParticipantApproved(\n        string participantName,\n        string participantTwitterHandle,\n        address indexed participantAddress\n    );\n\n    event PromiseLocked();\n\n    /// Modifiers\n    modifier onlyParticipant() {\n        address[] memory participantAddresses = s_participantAddresses;\n        bool isParticipant = false;\n\n        // The owner will probably interact more with the contract\n        // So we can save some gas by checking it first\n        if (i_owner == msg.sender) {\n            isParticipant = true;\n        } else {\n            // Loop through the parties and check if the sender is a party\n            for (uint256 i = 0; i < s_participantCount; i++) {\n                if (participantAddresses[i] == msg.sender) {\n                    isParticipant = true;\n                    break;\n                }\n            }\n        }\n\n        if (!isParticipant) revert PromiseContract__NOT_PARTICIPANT();\n        _;\n    }\n\n    modifier onlyUnlocked() {\n        if (s_promiseLocked) revert PromiseContract__PROMISE_LOCKED();\n        _;\n    }\n\n    /// Functions\n    /**\n     * @dev Initialize the contract from the Master Contract with the user address as the owner\n     */\n\n    constructor(\n        address _owner,\n        string memory _promiseName,\n        string memory _pdfUri,\n        string[] memory _partyNames,\n        string[] memory _partyTwitterHandles,\n        address[] memory _partyAddresses\n    ) {\n        i_owner = _owner;\n        s_promiseName = _promiseName;\n        s_pdfUri = _pdfUri;\n        s_participantCount = _partyAddresses.length;\n\n        for (uint256 i = 0; i < _partyAddresses.length; i++) {\n            _createParticipant(\n                _partyNames[i],\n                _partyTwitterHandles[i],\n                _partyAddresses[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Approve the promise as a participant\n     */\n\n    function approvePromise() public onlyParticipant onlyUnlocked {\n        if (s_approvedParties[msg.sender] == true) {\n            revert PromiseContract__approvePromise__ALREADY_APPROVED();\n        }\n\n        s_approvedParties[msg.sender] = true;\n        emit ParticipantApproved(\n            s_parties[msg.sender].participantName,\n            s_parties[msg.sender].participantTwitterHandle,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Validate the promise and lock it so that no more participants can change any state\n     * or even try to and lose gas\n     */\n\n    function lockPromise() public onlyParticipant onlyUnlocked {\n        address[] memory participantAddresses = s_participantAddresses;\n\n        // Loop through the parties and check if anyone has not approved yet\n        for (uint256 i = 0; i < s_participantCount; i++) {\n            if (s_approvedParties[participantAddresses[i]] == false) {\n                revert PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();\n            }\n        }\n\n        s_promiseLocked = true;\n        emit PromiseLocked();\n    }\n\n    /**\n     * @notice Create a new participant and add them to the mapping\n     * @dev This function can only be called during the contract creation\n     * @param _participantName The name of the participant\n     * @param _participantTwitterHandle The twitter handle of the participant\n     * @param _participantAddress The address of the participant\n     */\n\n    function _createParticipant(\n        string memory _participantName,\n        string memory _participantTwitterHandle,\n        address _participantAddress\n    ) private {\n        Participant memory participant = Participant(\n            _participantName,\n            _participantTwitterHandle,\n            _participantAddress\n        );\n        s_parties[_participantAddress] = participant;\n        s_participantAddresses.push(_participantAddress);\n\n        emit ParticipantCreated(\n            _participantName,\n            _participantTwitterHandle,\n            _participantAddress\n        );\n    }\n\n    /// Getters\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getName() public view returns (string memory) {\n        return s_promiseName;\n    }\n\n    function getPdfUri() public view returns (string memory) {\n        return s_pdfUri;\n    }\n\n    function getParticipant(address _participantAddress)\n        public\n        view\n        returns (Participant memory)\n    {\n        if (s_parties[_participantAddress].participantAddress == address(0)) {\n            revert PromiseContract__NOT_PARTICIPANT();\n        }\n\n        return s_parties[_participantAddress];\n    }\n\n    function getParticipantCount() public view returns (uint256) {\n        return s_participantCount;\n    }\n\n    function getParticipantAddresses() public view returns (address[] memory) {\n        return s_participantAddresses;\n    }\n\n    function getIsPromiseApproved(address _participantAddress)\n        public\n        view\n        returns (bool)\n    {\n        return s_approvedParties[_participantAddress];\n    }\n\n    function getIsPromiseLocked() public view returns (bool) {\n        return s_promiseLocked;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}