// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

/**
 * @author polarzero
 * @title Promise Contract
 * @notice This is the child contract generated by the Promise Factory
 * once a user creates a new promise
 */

contract PromiseContract {
    /// Errors
    error PromiseContract__NOT_FACTORY();
    error PromiseContract__NOT_PARTICIPANT();
    error PromiseContract__PROMISE_LOCKED();
    error PromiseContract__createParticipant__INCORRECT_FIELD_LENGTH();
    error PromiseContract__approvePromise__ALREADY_APPROVED();
    error PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();
    error PromiseContract__updateBackupStatus__INVALID_STATUS();

    /// Types
    struct Participant {
        string participantName;
        string participantTwitterHandle;
        address participantAddress;
    }

    /// Variables
    uint256 private s_participantCount = 0;
    // If the promise is created through the website, the content uploaded to IPFS
    // and eventually Arweave can be verified with the encryptedBytes32
    // which will result in a backupStatus that provides information on the persistence of the data
    // backupStatus = 0 -> the provided IPFS and Arweave hashes have not yet been verified
    // backupStatus = 1 -> the provided IPFS and eventually Arweave hashes could not be verified
    // backupStatus = 2 -> only the IPFS hash has been provided and verified
    // backupStatus = 3 -> both the IPFS & Arweave hashes has been provided and verified
    uint8 private s_backupStatus = 0;
    // The 3 following variables need to be stored in a string because of their length
    // So they cannot be set to immutable
    string private s_promiseName;
    string private s_ipfsCid;
    string private s_arweaveId;
    bytes32 private immutable i_encryptedBytes32;
    address private immutable i_owner;
    address private immutable i_promiseFactoryContract;
    address[] private s_participantAddresses;
    bool private s_promiseLocked = false;

    // Mapping of addresses to name & twitter handle
    mapping(address => Participant) private s_parties;
    // Mapping of addresses to whether or not they have approved the agreement
    mapping(address => bool) private s_approvedParties;

    /// Events
    event ParticipantCreated(
        string participantName,
        string participantTwitterHandle,
        address indexed participantAddress
    );

    event ParticipantApproved(
        string participantName,
        string participantTwitterHandle,
        address indexed participantAddress
    );

    event PromiseLocked();

    event PromiseBackupStatusUpdated(uint8 backupStatus);

    /// Modifiers
    modifier onlyParticipant() {
        bool isParticipant = getIsParticipant(msg.sender);

        if (!isParticipant) revert PromiseContract__NOT_PARTICIPANT();
        _;
    }

    modifier onlyUnlocked() {
        if (s_promiseLocked) revert PromiseContract__PROMISE_LOCKED();
        _;
    }

    modifier onlyPromiseFactory() {
        if (msg.sender != i_promiseFactoryContract)
            revert PromiseContract__NOT_FACTORY();
        _;
    }

    /// Functions
    /**
     * @dev Initialize the contract from the Master Contract with the user address as the owner
     */

    constructor(
        address _owner,
        string memory _promiseName,
        string memory _ipfsCid,
        string memory _arweaveId,
        bytes32 _encryptedBytes32,
        string[] memory _partyNames,
        string[] memory _partyTwitterHandles,
        address[] memory _partyAddresses
    ) {
        i_promiseFactoryContract = msg.sender;
        i_owner = _owner;
        s_promiseName = _promiseName;
        s_ipfsCid = _ipfsCid;
        s_arweaveId = _arweaveId;
        i_encryptedBytes32 = _encryptedBytes32;

        for (uint256 i = 0; i < _partyAddresses.length; i++) {
            createParticipant(
                _partyNames[i],
                _partyTwitterHandles[i],
                _partyAddresses[i],
                false // The promise is being initialized, no need to reset approval status
            );
        }
    }

    /**
     * @notice Approve the promise as a participant
     */

    function approvePromise() public onlyParticipant onlyUnlocked {
        if (s_approvedParties[msg.sender] == true) {
            revert PromiseContract__approvePromise__ALREADY_APPROVED();
        }

        s_approvedParties[msg.sender] = true;
        emit ParticipantApproved(
            s_parties[msg.sender].participantName,
            s_parties[msg.sender].participantTwitterHandle,
            msg.sender
        );
    }

    /**
     * @notice Validate the promise and lock it so that no more participants can change any state
     * or even try to and lose gas
     */

    function lockPromise() public onlyParticipant onlyUnlocked {
        address[] memory participantAddresses = s_participantAddresses;

        // Loop through the parties and check if anyone has not approved yet
        for (uint256 i = 0; i < s_participantCount; i++) {
            if (s_approvedParties[participantAddresses[i]] == false) {
                revert PromiseContract__lockPromise__PARTICIPANT_NOT_APPROVED();
            }
        }

        s_promiseLocked = true;
        emit PromiseLocked();
    }

    /**
     * @notice Create a new participant and add them to the mapping
     * @dev This function can only be called by the Promise Factory
     * @param _participantName The name of the participant
     * @param _participantTwitterHandle The twitter handle of the participant
     * @param _participantAddress The address of the participant
     */

    function createParticipant(
        string memory _participantName,
        string memory _participantTwitterHandle,
        address _participantAddress,
        bool _checkApprovalStatus
    ) public onlyPromiseFactory onlyUnlocked {
        // Revert if the name is not between 2 and 30 characters
        if (
            bytes(_participantName).length < 2 ||
            bytes(_participantName).length > 30
        ) {
            revert PromiseContract__createParticipant__INCORRECT_FIELD_LENGTH();
        }
        Participant memory participant = Participant(
            _participantName,
            _participantTwitterHandle,
            _participantAddress
        );
        s_parties[_participantAddress] = participant;
        s_participantAddresses.push(_participantAddress);
        s_participantCount++;

        // Make sure the promise gets disapproved for every participants
        // In case a new participant is added, they will need to approve it again
        // We just need to do this if a participant is being added, not at the initialization
        if (_checkApprovalStatus) {
            address[] memory participantAddresses = s_participantAddresses;

            for (uint256 i = 0; i < s_participantCount; i++) {
                // Set the approval to false if it's been approved already
                if (s_approvedParties[participantAddresses[i]] == true) {
                    s_approvedParties[participantAddresses[i]] = false;
                }
            }
        }

        emit ParticipantCreated(
            _participantName,
            _participantTwitterHandle,
            _participantAddress
        );
    }

    /**
     * @notice Update the backup status of the promise
     * @dev This function can only be called by the Promise Factory
     * @param _backupStatus The new backup status of the promise
     * - 1 -> the provided IPFS and eventually Arweave hashes could not be verified
     * - 2 -> only the IPFS hash has been provided and verified
     * - 3 -> both the IPFS & Arweave hashes has been provided and verified
     */

    function updateBackupStatus(uint8 _backupStatus) public onlyPromiseFactory {
        if (_backupStatus < 1 || _backupStatus > 3) {
            revert PromiseContract__updateBackupStatus__INVALID_STATUS();
        }

        s_backupStatus = _backupStatus;
        emit PromiseBackupStatusUpdated(_backupStatus);
    }

    /// Getters
    function getOwner() public view returns (address) {
        return i_owner;
    }

    function getName() public view returns (string memory) {
        return s_promiseName;
    }

    function getIpfsCid() public view returns (string memory) {
        return s_ipfsCid;
    }

    function getArweaveId() public view returns (string memory) {
        return s_arweaveId;
    }

    function getEncryptedBytes32() public view returns (bytes32) {
        return i_encryptedBytes32;
    }

    function getBackupStatus() public view returns (uint8) {
        return s_backupStatus;
    }

    function getParticipant(address _address)
        public
        view
        returns (Participant memory)
    {
        return s_parties[_address];
    }

    function getIsParticipant(address _participantAddress)
        public
        view
        returns (bool)
    {
        if (s_parties[_participantAddress].participantAddress == address(0)) {
            return false;
        }

        return true;
    }

    function getParticipantCount() public view returns (uint256) {
        return s_participantCount;
    }

    function getIsPromiseApproved(address _participantAddress)
        public
        view
        returns (bool)
    {
        return s_approvedParties[_participantAddress];
    }

    function getIsPromiseLocked() public view returns (bool) {
        return s_promiseLocked;
    }

    function getPromiseFactoryContract() public view returns (address) {
        return i_promiseFactoryContract;
    }
}
